"use strict";

exports.__esModule = true;
exports.decodeContent = decodeContent;
exports.encodeContent = encodeContent;

var _zlib = _interopRequireDefault(require("zlib"));

var _promisifiedFunctions = require("../../utils/promisified-functions");

var _iconvLite = _interopRequireDefault(require("iconv-lite"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/*eslint-enable no-unused-vars*/
const GZIP_CONTENT_ENCODING = 'gzip';
const DEFLATE_CONTENT_ENCODING = 'deflate';
const BROTLI_CONTENT_ENCODING = 'br'; // NOTE: IIS has a bug when it sends 'raw deflate' compressed data for the 'Deflate' Accept-Encoding header.
// (see: http://zoompf.com/2012/02/lose-the-wait-http-compression)

function inflateWithFallback(_x) {
  return _inflateWithFallback.apply(this, arguments);
}

function _inflateWithFallback() {
  _inflateWithFallback = _asyncToGenerator(function* (data) {
    try {
      return yield (0, _promisifiedFunctions.inflate)(data);
    } catch (err) {
      if (err.code === 'Z_DATA_ERROR') return yield (0, _promisifiedFunctions.inflateRaw)(data);
      throw err;
    }
  });
  return _inflateWithFallback.apply(this, arguments);
}

function decodeContent(_x2, _x3, _x4) {
  return _decodeContent.apply(this, arguments);
}

function _decodeContent() {
  _decodeContent = _asyncToGenerator(function* (content, encoding, charset) {
    if (encoding === GZIP_CONTENT_ENCODING) {
      // NOTE: https://github.com/request/request/pull/2492/files
      // Be more lenient with decoding compressed responses, since (very rarely)
      // servers send slightly invalid gzip responses that are still accepted
      // by common browsers.
      // Always using Z_SYNC_FLUSH is what cURL does.
      // GH-1915
      content = yield (0, _promisifiedFunctions.gunzip)(content, {
        flush: _zlib.default.Z_SYNC_FLUSH,
        finishFlush: _zlib.default.Z_SYNC_FLUSH
      });
    } else if (encoding === DEFLATE_CONTENT_ENCODING) content = yield inflateWithFallback(content);else if (encoding === BROTLI_CONTENT_ENCODING) content = Buffer.from(require('brotli').decompress(content));

    charset.fromBOM(content);
    return _iconvLite.default.decode(content, charset.get());
  });
  return _decodeContent.apply(this, arguments);
}

function encodeContent(_x5, _x6, _x7) {
  return _encodeContent.apply(this, arguments);
}

function _encodeContent() {
  _encodeContent = _asyncToGenerator(function* (content, encoding, charset) {
    content = _iconvLite.default.encode(content, charset.get(), {
      addBOM: charset.isFromBOM()
    });
    if (encoding === GZIP_CONTENT_ENCODING) return (0, _promisifiedFunctions.gzip)(content);
    if (encoding === DEFLATE_CONTENT_ENCODING) return (0, _promisifiedFunctions.deflate)(content);
    if (encoding === BROTLI_CONTENT_ENCODING) return Buffer.from(require('brotli').compress(content));
    return content;
  });
  return _encodeContent.apply(this, arguments);
}