"use strict";

exports.__esModule = true;
exports.default = transform;
exports.State = void 0;

var _transformers = _interopRequireDefault(require("./transformers"));

var _replaceNode = _interopRequireDefault(require("./transformers/replace-node"));

var _esotopeHammerhead = require("esotope-hammerhead");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class State {
  constructor() {
    _defineProperty(this, "hasTransformedAncestor", false);

    _defineProperty(this, "newExpressionAncestor", void 0);

    _defineProperty(this, "newExpressionAncestorParent", void 0);

    _defineProperty(this, "newExpressionAncestorKey", void 0);
  }

  // NOTE: There is an issue with processing `new` expressions. `new a.src.b()` will be transformed
  // to `new __get$(a, 'src').b()`, which is wrong. The correct result is `new (__get$(a, 'src')).b()`.
  // To solve this problem, we add a 'state' entity. This entity stores the "new" expression, so that
  // we can add it to the changes when the transformation is found.
  static create(currState, node, parent, key, hasTransformedAncestor) {
    const isNewExpression = node.type === _esotopeHammerhead.Syntax.NewExpression;
    const isNewExpressionAncestor = isNewExpression && !currState.newExpressionAncestor;
    const newState = new State();
    newState.hasTransformedAncestor = currState.hasTransformedAncestor || hasTransformedAncestor;
    newState.newExpressionAncestor = isNewExpressionAncestor ? node : currState.newExpressionAncestor;
    newState.newExpressionAncestorParent = isNewExpressionAncestor ? parent : currState.newExpressionAncestorParent;
    newState.newExpressionAncestorKey = isNewExpressionAncestor ? key : currState.newExpressionAncestorKey;
    return newState;
  }

}

exports.State = State;
// NOTE: We should avoid using native object prototype methods,
const objectToString = Object.prototype.toString;
const objectHasOwnProperty = Object.prototype.hasOwnProperty;

function getChange(node, parent, key) {
  const _ref = node,
        start = _ref.originStart,
        end = _ref.originEnd;
  const index = Array.isArray(parent[key]) ? parent[key].indexOf(node) : -1;
  return {
    start,
    end,
    index,
    parent,
    key
  };
}

function transformChildNodes(node, changes, state) {
  for (const key in node) {
    if (objectHasOwnProperty.call(node, key)) {
      const childNode = node[key];
      const stringifiedNode = objectToString.call(childNode);

      if (stringifiedNode === '[object Array]') {
        for (let j = 0; j < childNode.length; j++) transform(childNode[j], changes, state, node, key);
      } else if (stringifiedNode === '[object Object]') transform(childNode, changes, state, node, key);
    }
  }
}

function isNodeTransformed(node) {
  // eslint-disable-next-line no-extra-parens
  return node.originStart !== void 0 && node.originEnd !== void 0;
}

function addChangeForTransformedNode(state, changes, replacement, parent, key) {
  const hasTransformedAncestor = state.hasTransformedAncestor || state.newExpressionAncestor && isNodeTransformed(state.newExpressionAncestor);
  if (hasTransformedAncestor) return;

  if (state.newExpressionAncestor) {
    (0, _replaceNode.default)(state.newExpressionAncestor, state.newExpressionAncestor, state.newExpressionAncestorParent, state.newExpressionAncestorKey);
    changes.push(getChange(state.newExpressionAncestor, state.newExpressionAncestorParent, state.newExpressionAncestorKey));
  } else changes.push(getChange(replacement, parent, key));
}

function transform(node, changes = [], state = new State(), parent, key, reTransform) {
  if (!node || typeof node !== 'object') return null;
  let nodeChanged = false;

  if (isNodeTransformed(node) && !reTransform) {
    addChangeForTransformedNode(state, changes, node, parent, key);
    nodeChanged = true;
  } else {
    const nodeTransformers = _transformers.default.get(node.type);

    if (nodeTransformers) {
      for (let i = 0; i < nodeTransformers.length; i++) {
        const transformer = nodeTransformers[i];

        if (transformer.condition(node, parent)) {
          const replacement = transformer.run(node, parent, key);

          if (replacement) {
            (0, _replaceNode.default)(node, replacement, parent, key);
            nodeChanged = true;
            addChangeForTransformedNode(state, changes, replacement, parent, key);

            if (transformer.nodeReplacementRequireTransform) {
              state = State.create(state, replacement, parent, key, nodeChanged);
              transform(replacement, changes, state, parent, key, true);
              return changes;
            }

            break;
          }
        }
      }
    }
  }

  state = State.create(state, node, parent, key, nodeChanged);
  transformChildNodes(node, changes, state);
  return changes;
}