"use strict";

exports.__esModule = true;
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _mime = _interopRequireDefault(require("mime"));

var _events = require("events");

var _url = require("url");

var _messages = require("../messages");

var _promisifiedFunctions = require("../utils/promisified-functions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const DISK_RE = /^\/[A-Za-z]:/;
const TARGET_IS_NOT_FILE = 'The target of the operation is not a file';

class FileRequest extends _events.EventEmitter {
  constructor(url) {
    super();

    _defineProperty(this, "url", void 0);

    _defineProperty(this, "path", void 0);

    this.url = url;
    this.path = FileRequest._getPath(url);

    this._initEvents();
  }

  _initEvents() {
    (0, _promisifiedFunctions.stat)(this.path).then(stats => {
      if (!stats.isFile()) throw new Error(TARGET_IS_NOT_FILE);
      return (0, _promisifiedFunctions.access)(this.path, _fs.default.constants.R_OK);
    }).then(() => this._onOpen()).catch(err => this._onError(err));
  }

  static _getPath(proxiedUrl) {
    const parsedUrl = (0, _url.parse)(proxiedUrl); // @ts-ignore

    let path = decodeURIComponent(parsedUrl.pathname);
    if (DISK_RE.test(path)) path = path.substr(1);
    return path;
  }

  _onError(err) {
    this.emit('fatalError', (0, _messages.getText)(_messages.MESSAGE.cantReadFile, this.url, err.message));
  }

  _onOpen() {
    let stream = _fs.default.createReadStream(this.path);

    stream = Object.assign(stream, {
      statusCode: 200,
      trailers: {},
      headers: {
        'content-type': _mime.default.lookup(this.path)
      }
    });
    this.emit('response', stream);
  }

}

exports.default = FileRequest;
module.exports = exports.default;