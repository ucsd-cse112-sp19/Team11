"use strict";

exports.__esModule = true;
exports.run = run;

var _context = _interopRequireDefault(require("./context"));

var _resources = require("../processing/resources");

var _messages = require("../messages");

var _connectionResetGuard = _interopRequireDefault(require("./connection-reset-guard"));

var _sameOriginCheckFailedStatusCode = _interopRequireDefault(require("./xhr/same-origin-check-failed-status-code"));

var _http = require("../utils/http");

var _websocket = require("./websocket");

var _specialPage = _interopRequireDefault(require("./special-page"));

var _info = require("../session/events/info");

var _names = _interopRequireDefault(require("../session/events/names"));

var _configureResponseEvent = _interopRequireDefault(require("../session/events/configure-response-event"));

var _configureResponseEventOptions = _interopRequireDefault(require("../session/events/configure-response-event-options"));

var _lodash = require("lodash");

var _requestOptions = _interopRequireDefault(require("./request-options"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const EVENT_SOURCE_REQUEST_TIMEOUT = 60 * 60 * 1000;
const stages = [function handleSocketError(ctx) {
  // NOTE: In some case on MacOS, browser reset connection with server and we need to catch this exception.
  if (!ctx.isWebSocket) return;
  ctx.res.on('error', e => {
    // @ts-ignore
    if (e.code === 'ECONNRESET' && !ctx.mock) {
      if (ctx.destRes) ctx.destRes.destroy();else ctx.isWebSocketConnectionReset = true;
    } else throw e;
  });
},
/*#__PURE__*/
function () {
  var _fetchProxyRequestBody = _asyncToGenerator(function* (ctx) {
    if (ctx.isPage && !ctx.isIframe && !ctx.isHtmlImport) ctx.session.onPageRequest(ctx);
    ctx.reqBody = yield (0, _http.fetchBody)(ctx.req);
  });

  function fetchProxyRequestBody(_x) {
    return _fetchProxyRequestBody.apply(this, arguments);
  }

  return fetchProxyRequestBody;
}(),
/*#__PURE__*/
function () {
  var _sendDestinationRequest = _asyncToGenerator(function* (ctx) {
    if (ctx.isSpecialPage) {
      ctx.destRes = (0, _specialPage.default)();
      return;
    }

    ctx.reqOpts = new _requestOptions.default(ctx);

    if (ctx.session.hasRequestEventListeners()) {
      const requestInfo = new _info.RequestInfo(ctx, ctx.reqOpts);
      ctx.requestFilterRules = ctx.session.getRequestFilterRules(requestInfo);
      yield ctx.forEachRequestFilterRule(
      /*#__PURE__*/
      function () {
        var _ref = _asyncToGenerator(function* (rule) {
          yield (0, _utils.callOnRequestEventCallback)(ctx, rule, requestInfo);
          ctx.setupMockIfNecessary(rule);
        });

        return function (_x3) {
          return _ref.apply(this, arguments);
        };
      }());
    }

    if (ctx.mock) ctx.mockResponse();else yield (0, _utils.sendRequest)(ctx);
  });

  function sendDestinationRequest(_x2) {
    return _sendDestinationRequest.apply(this, arguments);
  }

  return sendDestinationRequest;
}(),
/*#__PURE__*/
function () {
  var _checkSameOriginPolicyCompliance = _asyncToGenerator(function* (ctx) {
    ctx.buildContentInfo();
    if (ctx.isPassSameOriginPolicy()) return;
    ctx.isSameOriginPolicyFailed = true;
    yield ctx.forEachRequestFilterRule(
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(function* (rule) {
        const configureResponseEvent = new _configureResponseEvent.default(ctx, rule, _configureResponseEventOptions.default.DEFAULT);
        yield ctx.session.callRequestEventCallback(_names.default.onConfigureResponse, rule, configureResponseEvent);
        yield (0, _utils.callOnResponseEventCallbackForFailedSameOriginCheck)(ctx, rule, configureResponseEvent);
      });

      return function (_x5) {
        return _ref2.apply(this, arguments);
      };
    }());
    ctx.closeWithError(_sameOriginCheckFailedStatusCode.default);
  });

  function checkSameOriginPolicyCompliance(_x4) {
    return _checkSameOriginPolicyCompliance.apply(this, arguments);
  }

  return checkSameOriginPolicyCompliance;
}(),
/*#__PURE__*/
function () {
  var _decideOnProcessingStrategy = _asyncToGenerator(function* (ctx) {
    ctx.goToNextStage = false;

    if (ctx.isWebSocket) {
      (0, _websocket.respondOnWebSocket)(ctx);
      return;
    }

    if (ctx.contentInfo.requireProcessing && ctx.destRes.statusCode === 204) ctx.destRes.statusCode = 200; // NOTE: Just pipe the content body to the browser if we don't need to process it.
    else if (!ctx.contentInfo.requireProcessing) {
        if (!ctx.isSpecialPage) {
          yield (0, _utils.callOnConfigureResponseEventForNonProcessedRequest)(ctx);
          ctx.sendResponseHeaders();
          if (ctx.contentInfo.isNotModified) yield (0, _utils.callOnResponseEventCallbackForMotModifiedResource)(ctx);else {
            const onResponseEventDataWithBody = ctx.getOnResponseEventData({
              includeBody: true
            });
            const onResponseEventDataWithoutBody = ctx.getOnResponseEventData({
              includeBody: false
            });
            if (onResponseEventDataWithBody.length) yield (0, _utils.callOnResponseEventCallbackWithBodyForNonProcessedRequest)(ctx, onResponseEventDataWithBody);else if (onResponseEventDataWithoutBody.length) yield (0, _utils.callOnResponseEventCallbackWithoutBodyForNonProcessedResource)(ctx, onResponseEventDataWithoutBody);else ctx.destRes.pipe(ctx.res);
          } // NOTE: sets 60 minutes timeout for the "event source" requests instead of 2 minutes by default

          if (ctx.dest.isEventSource) {
            ctx.req.setTimeout(EVENT_SOURCE_REQUEST_TIMEOUT, _lodash.noop);
            ctx.req.on('close', () => ctx.destRes.destroy());
          }
        } else {
          ctx.sendResponseHeaders();
          ctx.res.end();
        }

        return;
      }
    ctx.goToNextStage = true;
  });

  function decideOnProcessingStrategy(_x6) {
    return _decideOnProcessingStrategy.apply(this, arguments);
  }

  return decideOnProcessingStrategy;
}(),
/*#__PURE__*/
function () {
  var _fetchContent = _asyncToGenerator(function* (ctx) {
    ctx.destResBody = yield (0, _http.fetchBody)(ctx.destRes);
    if (ctx.requestFilterRules.length) ctx.saveNonProcessedDestResBody(ctx.destResBody); // NOTE: Sometimes the underlying socket emits an error event. But if we have a response body,
    // we can still process such requests. (B234324)

    if (ctx.hasDestReqErr && ctx.isDestResBodyMalformed()) {
      (0, _utils.error)(ctx, (0, _messages.getText)(_messages.MESSAGE.destConnectionTerminated, ctx.dest.url));
      ctx.goToNextStage = false;
    }
  });

  function fetchContent(_x7) {
    return _fetchContent.apply(this, arguments);
  }

  return fetchContent;
}(),
/*#__PURE__*/
function () {
  var _processContent = _asyncToGenerator(function* (ctx) {
    try {
      ctx.destResBody = yield (0, _resources.process)(ctx);
    } catch (err) {
      (0, _utils.error)(ctx, err);
    }
  });

  function processContent(_x8) {
    return _processContent.apply(this, arguments);
  }

  return processContent;
}(),
/*#__PURE__*/
function () {
  var _sendProxyResponse = _asyncToGenerator(function* (ctx) {
    const configureResponseEvents = yield Promise.all(ctx.requestFilterRules.map(
    /*#__PURE__*/
    function () {
      var _ref3 = _asyncToGenerator(function* (rule) {
        const configureResponseEvent = new _configureResponseEvent.default(ctx, rule, _configureResponseEventOptions.default.DEFAULT);
        yield ctx.session.callRequestEventCallback(_names.default.onConfigureResponse, rule, configureResponseEvent);
        return configureResponseEvent;
      });

      return function (_x10) {
        return _ref3.apply(this, arguments);
      };
    }()));
    ctx.sendResponseHeaders();
    (0, _connectionResetGuard.default)(
    /*#__PURE__*/
    _asyncToGenerator(function* () {
      yield Promise.all(configureResponseEvents.map(
      /*#__PURE__*/
      function () {
        var _ref5 = _asyncToGenerator(function* (configureResponseEvent) {
          yield (0, _utils.callResponseEventCallbackForProcessedRequest)(ctx, configureResponseEvent);
        });

        return function (_x11) {
          return _ref5.apply(this, arguments);
        };
      }()));
      const res = ctx.res;
      res.write(ctx.destResBody);
      ctx.res.end();
    }));
  });

  function sendProxyResponse(_x9) {
    return _sendProxyResponse.apply(this, arguments);
  }

  return sendProxyResponse;
}()];

function run(_x12, _x13, _x14, _x15) {
  return _run.apply(this, arguments);
}

function _run() {
  _run = _asyncToGenerator(function* (req, res, serverInfo, openSessions) {
    const ctx = new _context.default(req, res, serverInfo);

    if (!ctx.dispatch(openSessions)) {
      (0, _http.respond404)(res);
      return;
    }

    for (let i = 0; i < stages.length; i++) {
      yield stages[i](ctx);
      if (!ctx.goToNextStage) return;
    }
  });
  return _run.apply(this, arguments);
}