"use strict";

exports.__esModule = true;
exports.default = void 0;

var _names = _interopRequireDefault(require("../session/events/names"));

var _stateSnapshot = _interopRequireDefault(require("./state-snapshot"));

var _mustache = _interopRequireDefault(require("mustache"));

var _readFileRelative = require("read-file-relative");

var _events = require("events");

var _url = require("url");

var _cookies = _interopRequireDefault(require("./cookies"));

var _storage = _interopRequireDefault(require("../upload/storage"));

var _command = _interopRequireDefault(require("./command"));

var _generateUniqueId = _interopRequireDefault(require("../utils/generate-unique-id"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const TASK_TEMPLATE = (0, _readFileRelative.readSync)('../client/task.js.mustache');
var _COMMAND$uploadFiles = _command.default.uploadFiles;
var _COMMAND$getUploadedF = _command.default.getUploadedFiles;

class Session extends _events.EventEmitter {
  constructor(uploadsRoot) {
    super();

    _defineProperty(this, "uploadStorage", void 0);

    _defineProperty(this, "id", (0, _generateUniqueId.default)());

    _defineProperty(this, "cookies", new _cookies.default());

    _defineProperty(this, "proxy", null);

    _defineProperty(this, "externalProxySettings", null);

    _defineProperty(this, "pageLoadCount", 0);

    _defineProperty(this, "pendingStateSnapshot", null);

    _defineProperty(this, "injectable", {
      scripts: ['/hammerhead.js'],
      styles: []
    });

    _defineProperty(this, "requestEventListeners", new Map());

    _defineProperty(this, "mocks", new Map());

    this.uploadStorage = new _storage.default(uploadsRoot);
  } // State


  getStateSnapshot() {
    return new _stateSnapshot.default(this.cookies.serializeJar(), null);
  }

  useStateSnapshot(snapshot) {
    if (!snapshot) throw new Error('"snapshot" parameter cannot be null. Use StateSnapshot.empty() instead of it.'); // NOTE: we don't perform state switch immediately, since there might be
    // pending requests from current page. Therefore, we perform switch in
    // onPageRequest handler when new page is requested.

    this.pendingStateSnapshot = snapshot;
  }

  handleServiceMessage(msg, serverInfo) {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (_this[msg.cmd]) return yield _this[msg.cmd](msg, serverInfo);
      throw new Error('Malformed service message or message handler is not implemented');
    })();
  }

  _fillTaskScriptTemplate({
    serverInfo,
    isFirstPageLoad,
    referer,
    cookie,
    iframeTaskScriptTemplate,
    payloadScript
  }) {
    referer = referer && JSON.stringify(referer) || '{{{referer}}}';
    cookie = cookie || '{{{cookie}}}';
    iframeTaskScriptTemplate = iframeTaskScriptTemplate || '{{{iframeTaskScriptTemplate}}}';
    const domain = serverInfo.domain,
          crossDomainPort = serverInfo.crossDomainPort;
    return _mustache.default.render(TASK_TEMPLATE, {
      sessionId: this.id,
      serviceMsgUrl: domain + '/messaging',
      forceProxySrcForImage: this.hasRequestEventListeners(),
      crossDomainPort,
      isFirstPageLoad,
      referer,
      cookie,
      iframeTaskScriptTemplate,
      payloadScript
    });
  }

  getIframeTaskScriptTemplate(serverInfo) {
    const taskScriptTemplate = this._fillTaskScriptTemplate({
      serverInfo,
      isFirstPageLoad: false,
      referer: null,
      cookie: null,
      iframeTaskScriptTemplate: null,
      payloadScript: this._getIframePayloadScript(true)
    });

    return JSON.stringify(taskScriptTemplate);
  }

  getTaskScript({
    referer,
    cookieUrl,
    serverInfo,
    isIframe,
    withPayload
  }) {
    const cookies = JSON.stringify(this.cookies.getClientString(cookieUrl));
    let payloadScript = '';
    if (withPayload) payloadScript = isIframe ? this._getIframePayloadScript(false) : this._getPayloadScript();

    const taskScript = this._fillTaskScriptTemplate({
      serverInfo,
      isFirstPageLoad: this.pageLoadCount === 0,
      referer,
      cookie: cookies,
      iframeTaskScriptTemplate: this.getIframeTaskScriptTemplate(serverInfo),
      payloadScript
    });

    this.pageLoadCount++;
    return taskScript;
  }

  setExternalProxySettings(proxySettings) {
    if (typeof proxySettings === 'string') proxySettings = {
      url: proxySettings
    };
    if (!proxySettings || !proxySettings.url) return;
    const _proxySettings = proxySettings,
          url = _proxySettings.url,
          bypassRules = _proxySettings.bypassRules;
    const parsedUrl = (0, _url.parse)('http://' + url);
    let settings = null;

    if (parsedUrl && parsedUrl.host) {
      settings = {
        host: parsedUrl.host,
        hostname: parsedUrl.hostname
      };
      if (bypassRules) settings.bypassRules = bypassRules;
      if (parsedUrl.port) settings.port = parsedUrl.port;

      if (parsedUrl.auth) {
        settings.proxyAuth = parsedUrl.auth;
        settings.authHeader = 'Basic ' + Buffer.from(parsedUrl.auth).toString('base64');
      }
    }

    this.externalProxySettings = settings;
  }

  onPageRequest(ctx) {
    if (!this.pendingStateSnapshot) return;
    this.cookies.setJar(this.pendingStateSnapshot.cookies);
    ctx.restoringStorages = this.pendingStateSnapshot.storages;
    this.pendingStateSnapshot = null;
  } // Request hooks


  hasRequestEventListeners() {
    return !!this.requestEventListeners.size;
  }

  addRequestEventListeners(requestFilterRule, eventListeners) {
    this.requestEventListeners.set(requestFilterRule, eventListeners);
  }

  removeRequestEventListeners(requestFilterRule) {
    this.requestEventListeners.delete(requestFilterRule);
  }

  getRequestFilterRules(requestInfo) {
    const rulesArray = Array.from(this.requestEventListeners.keys());
    return rulesArray.filter(rule => rule.match(requestInfo));
  }

  callRequestEventCallback(eventName, requestFilterRule, eventData) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const eventListeners = _this2.requestEventListeners.get(requestFilterRule);

      const targetRequestEventCallback = eventListeners[eventName];
      if (typeof targetRequestEventCallback === 'function') yield targetRequestEventCallback(eventData);
    })();
  }

  setMock(requestFilterRule, mock) {
    this.mocks.set(requestFilterRule, mock);
  }

  getMock(requestFilterRule) {
    return this.mocks.get(requestFilterRule);
  }

  // Service message handlers
  [_COMMAND$uploadFiles](msg) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      return yield _this3.uploadStorage.store(msg.fileNames, msg.data);
    })();
  }

  [_COMMAND$getUploadedF](msg) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      return yield _this4.uploadStorage.get(msg.filePaths);
    })();
  }

}

exports.default = Session;
module.exports = exports.default;