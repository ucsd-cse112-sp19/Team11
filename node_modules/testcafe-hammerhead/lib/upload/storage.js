"use strict";

exports.__esModule = true;
exports.default = void 0;

var _mime = _interopRequireDefault(require("mime"));

var _path = _interopRequireDefault(require("path"));

var _util = require("util");

var _promisifiedFunctions = require("../utils/promisified-functions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class UploadStorage {
  constructor(uploadsRoot) {
    _defineProperty(this, "uploadsRoot", void 0);

    this.uploadsRoot = uploadsRoot;
  }

  static _getFilesToCopy(files) {
    return _asyncToGenerator(function* () {
      const filesToCopy = [];
      const errs = [];

      for (var _iterator = files, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        const file = _ref;

        try {
          const stats = yield (0, _promisifiedFunctions.stat)(file.path);
          if (stats.isFile()) filesToCopy.push(file);
        } catch (err) {
          errs.push({
            path: file.path,
            err
          });
        }
      }

      return {
        filesToCopy,
        errs
      };
    })();
  }

  static _generateName(existingNames, fileName) {
    const extName = _path.default.extname(fileName);

    const template = _path.default.basename(fileName, extName) + ' %s' + extName;
    let index = 0;

    while (existingNames.includes(fileName)) fileName = (0, _util.format)(template, ++index);

    return fileName;
  }

  static _getExistingFiles(uploadsRoot) {
    return _asyncToGenerator(function* () {
      try {
        return yield (0, _promisifiedFunctions.readDir)(uploadsRoot);
      } catch (e) {
        return [];
      }
    })();
  }

  store(fileNames, data) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const storedFiles = [];
      const err = yield UploadStorage.ensureUploadsRoot(_this.uploadsRoot);
      if (err) return [{
        err: err.toString(),
        path: _this.uploadsRoot
      }];
      const existingFiles = yield UploadStorage._getExistingFiles(_this.uploadsRoot);

      for (var _iterator2 = fileNames, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        const fileName = _ref2;

        const storedFileName = UploadStorage._generateName(existingFiles, fileName);

        const storedFilePath = _path.default.join(_this.uploadsRoot, storedFileName);

        try {
          yield (0, _promisifiedFunctions.writeFile)(storedFilePath, data[storedFiles.length], {
            encoding: 'base64'
          });
          existingFiles.push(storedFileName);
          storedFiles.push({
            path: storedFilePath,
            file: storedFileName
          });
        } catch (e) {
          storedFiles.push({
            err: e.toString(),
            path: storedFilePath,
            file: fileName
          });
        }
      }

      return storedFiles;
    })();
  }

  get(filePathList) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const result = [];

      for (var _iterator3 = filePathList, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        const filePath = _ref3;

        const resolvedPath = _path.default.resolve(_this2.uploadsRoot, filePath);

        try {
          const fileContent = yield (0, _promisifiedFunctions.readFile)(resolvedPath);
          const fileStats = yield (0, _promisifiedFunctions.stat)(resolvedPath);
          result.push({
            data: fileContent.toString('base64'),
            info: {
              lastModifiedDate: fileStats.mtime,
              name: _path.default.basename(resolvedPath),
              type: _mime.default.lookup(resolvedPath)
            }
          });
        } catch (e) {
          result.push({
            err: e.toString(),
            path: filePath,
            resolvedPath
          });
        }
      }

      return result;
    })();
  }

  static copy(uploadsRoot, files) {
    return _asyncToGenerator(function* () {
      const _ref4 = yield UploadStorage._getFilesToCopy(files),
            filesToCopy = _ref4.filesToCopy,
            errs = _ref4.errs;

      const copiedFiles = [];
      if (!filesToCopy.length) return {
        copiedFiles,
        errs
      };
      const existingFiles = yield UploadStorage._getExistingFiles(uploadsRoot);

      for (var _iterator4 = filesToCopy, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
        var _ref5;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref5 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref5 = _i4.value;
        }

        const file = _ref5;

        const copiedFileName = UploadStorage._generateName(existingFiles, file.name);

        const copiedFilePath = _path.default.join(uploadsRoot, copiedFileName);

        try {
          yield (0, _promisifiedFunctions.writeFile)(copiedFilePath, (yield (0, _promisifiedFunctions.readFile)(file.path, null)));
          existingFiles.push(copiedFileName);
          copiedFiles.push(copiedFilePath);
        } catch (err) {
          errs.push({
            path: file.path,
            err
          });
        }
      }

      return {
        copiedFiles,
        errs
      };
    })();
  }

  static ensureUploadsRoot(uploadsRoot) {
    return _asyncToGenerator(function* () {
      try {
        if (!(yield (0, _promisifiedFunctions.fsObjectExists)(uploadsRoot))) yield (0, _promisifiedFunctions.makeDir)(uploadsRoot);
        return null;
      } catch (err) {
        return err;
      }
    })();
  }

}

exports.default = UploadStorage;
module.exports = exports.default;