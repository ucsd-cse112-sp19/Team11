"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const pinkie_1 = __importDefault(require("pinkie"));
const qrcode_terminal_1 = __importDefault(require("qrcode-terminal"));
const chalk_1 = __importDefault(require("chalk"));
const log_1 = __importDefault(require("./log"));
const promisify_event_1 = __importDefault(require("promisify-event"));
const dedent_1 = __importDefault(require("dedent"));
async function default_1(testCafe, remoteCount, showQRCode) {
    const connectionPromises = [];
    if (remoteCount) {
        log_1.default.hideSpinner();
        const description = dedent_1.default(`
            Connecting ${remoteCount} remote browser(s)...
            Navigate to the following URL from each remote browser.
        `);
        log_1.default.write(description);
        if (showQRCode)
            log_1.default.write('You can either enter the URL or scan the QR-code.');
        const connectionUrl = testCafe.browserConnectionGateway.connectUrl;
        log_1.default.write(`Connect URL: ${chalk_1.default.underline.blue(connectionUrl)}`);
        if (showQRCode)
            qrcode_terminal_1.default.generate(connectionUrl);
        for (let i = 0; i < remoteCount; i++) {
            connectionPromises.push(testCafe
                .createBrowserConnection()
                .then(bc => promisify_event_1.default(bc, 'ready').then(() => bc))
                .then(bc => {
                log_1.default.write(`${chalk_1.default.green('CONNECTED')} ${bc.userAgent}`);
                return bc;
            }));
        }
        log_1.default.showSpinner();
    }
    return await pinkie_1.default.all(connectionPromises);
}
exports.default = default_1;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVtb3Rlcy13aXphcmQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvY2xpL3JlbW90ZXMtd2l6YXJkLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsb0RBQTZCO0FBQzdCLHNFQUFxQztBQUNyQyxrREFBMEI7QUFDMUIsZ0RBQXdCO0FBQ3hCLHNFQUE2QztBQUM3QyxvREFBNEI7QUFHYixLQUFLLG9CQUFXLFFBQVEsRUFBRSxXQUFXLEVBQUUsVUFBVTtJQUM1RCxNQUFNLGtCQUFrQixHQUFHLEVBQUUsQ0FBQztJQUU5QixJQUFJLFdBQVcsRUFBRTtRQUNiLGFBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUVsQixNQUFNLFdBQVcsR0FBRyxnQkFBTSxDQUFDO3lCQUNWLFdBQVc7O1NBRTNCLENBQUMsQ0FBQztRQUVILGFBQUcsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFdkIsSUFBSSxVQUFVO1lBQ1YsYUFBRyxDQUFDLEtBQUssQ0FBQyxtREFBbUQsQ0FBQyxDQUFDO1FBRW5FLE1BQU0sYUFBYSxHQUFHLFFBQVEsQ0FBQyx3QkFBd0IsQ0FBQyxVQUFVLENBQUM7UUFFbkUsYUFBRyxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsZUFBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRWpFLElBQUksVUFBVTtZQUNWLHlCQUFNLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRW5DLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDbEMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFFBQVE7aUJBQzNCLHVCQUF1QixFQUFFO2lCQUN6QixJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyx5QkFBYyxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7aUJBQ3RELElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDUCxhQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsZUFBSyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQztnQkFDekQsT0FBTyxFQUFFLENBQUM7WUFDZCxDQUFDLENBQUMsQ0FDTCxDQUFDO1NBQ0w7UUFFRCxhQUFHLENBQUMsV0FBVyxFQUFFLENBQUM7S0FDckI7SUFFRCxPQUFPLE1BQU0sZ0JBQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUNqRCxDQUFDO0FBdENELDRCQXNDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQcm9taXNlIGZyb20gJ3BpbmtpZSc7XG5pbXBvcnQgcXJjb2RlIGZyb20gJ3FyY29kZS10ZXJtaW5hbCc7XG5pbXBvcnQgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZyc7XG5pbXBvcnQgcHJvbWlzaWZ5RXZlbnQgZnJvbSAncHJvbWlzaWZ5LWV2ZW50JztcbmltcG9ydCBkZWRlbnQgZnJvbSAnZGVkZW50JztcblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiAodGVzdENhZmUsIHJlbW90ZUNvdW50LCBzaG93UVJDb2RlKSB7XG4gICAgY29uc3QgY29ubmVjdGlvblByb21pc2VzID0gW107XG5cbiAgICBpZiAocmVtb3RlQ291bnQpIHtcbiAgICAgICAgbG9nLmhpZGVTcGlubmVyKCk7XG5cbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBkZWRlbnQoYFxuICAgICAgICAgICAgQ29ubmVjdGluZyAke3JlbW90ZUNvdW50fSByZW1vdGUgYnJvd3NlcihzKS4uLlxuICAgICAgICAgICAgTmF2aWdhdGUgdG8gdGhlIGZvbGxvd2luZyBVUkwgZnJvbSBlYWNoIHJlbW90ZSBicm93c2VyLlxuICAgICAgICBgKTtcblxuICAgICAgICBsb2cud3JpdGUoZGVzY3JpcHRpb24pO1xuXG4gICAgICAgIGlmIChzaG93UVJDb2RlKVxuICAgICAgICAgICAgbG9nLndyaXRlKCdZb3UgY2FuIGVpdGhlciBlbnRlciB0aGUgVVJMIG9yIHNjYW4gdGhlIFFSLWNvZGUuJyk7XG5cbiAgICAgICAgY29uc3QgY29ubmVjdGlvblVybCA9IHRlc3RDYWZlLmJyb3dzZXJDb25uZWN0aW9uR2F0ZXdheS5jb25uZWN0VXJsO1xuXG4gICAgICAgIGxvZy53cml0ZShgQ29ubmVjdCBVUkw6ICR7Y2hhbGsudW5kZXJsaW5lLmJsdWUoY29ubmVjdGlvblVybCl9YCk7XG5cbiAgICAgICAgaWYgKHNob3dRUkNvZGUpXG4gICAgICAgICAgICBxcmNvZGUuZ2VuZXJhdGUoY29ubmVjdGlvblVybCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uUHJvbWlzZXMucHVzaCh0ZXN0Q2FmZVxuICAgICAgICAgICAgICAgIC5jcmVhdGVCcm93c2VyQ29ubmVjdGlvbigpXG4gICAgICAgICAgICAgICAgLnRoZW4oYmMgPT4gcHJvbWlzaWZ5RXZlbnQoYmMsICdyZWFkeScpLnRoZW4oKCkgPT4gYmMpKVxuICAgICAgICAgICAgICAgIC50aGVuKGJjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLndyaXRlKGAke2NoYWxrLmdyZWVuKCdDT05ORUNURUQnKX0gJHtiYy51c2VyQWdlbnR9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZy5zaG93U3Bpbm5lcigpO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChjb25uZWN0aW9uUHJvbWlzZXMpO1xufVxuIl19