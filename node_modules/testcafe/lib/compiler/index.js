'use strict';

exports.__esModule = true;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _lodash = require('lodash');

var _stripBom = require('strip-bom');

var _stripBom2 = _interopRequireDefault(_stripBom);

var _testcafeLegacyApi = require('testcafe-legacy-api');

var _testcafeHammerhead = require('testcafe-hammerhead');

var _testcafeHammerhead2 = _interopRequireDefault(_testcafeHammerhead);

var _compiler = require('./test-file/formats/es-next/compiler');

var _compiler2 = _interopRequireDefault(_compiler);

var _compiler3 = require('./test-file/formats/typescript/compiler');

var _compiler4 = _interopRequireDefault(_compiler3);

var _compiler5 = require('./test-file/formats/coffeescript/compiler');

var _compiler6 = _interopRequireDefault(_compiler5);

var _raw = require('./test-file/formats/raw');

var _raw2 = _interopRequireDefault(_raw);

var _promisifiedFunctions = require('../utils/promisified-functions');

var _runtime = require('../errors/runtime');

var _types = require('../errors/types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const SOURCE_CHUNK_LENGTH = 1000;

const testFileCompilers = [new _testcafeLegacyApi.Compiler(_testcafeHammerhead2.default.processScript), new _compiler2.default(), new _compiler4.default(), new _compiler6.default(), new _raw2.default()];

class Compiler {
    constructor(sources) {
        this.sources = sources;
    }

    static getSupportedTestFileExtensions() {
        return (0, _lodash.uniq)(testFileCompilers.map(compiler => compiler.getSupportedExtension()));
    }

    _createTestFileInfo(filename) {
        return (0, _asyncToGenerator3.default)(function* () {
            let code = null;

            try {
                code = yield (0, _promisifiedFunctions.readFile)(filename);
            } catch (err) {
                throw new _runtime.GeneralError(_types.RUNTIME_ERRORS.cannotFindSpecifiedTestSource, filename);
            }

            code = (0, _stripBom2.default)(code).toString();

            const compiler = (0, _lodash.find)(testFileCompilers, function (someCompiler) {
                return someCompiler.canCompile(code, filename);
            });

            if (!compiler) return null;

            return {
                filename,
                code,
                compiler,

                compiledCode: null
            };
        })();
    }

    _createTestFilesInfo(filenames) {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            const testFilesInfo = yield _pinkie2.default.all(filenames.map(function (filename) {
                return _this._createTestFileInfo(filename);
            }));

            return testFilesInfo.filter(function (info) {
                return !!info;
            });
        })();
    }

    _precompileFiles(compiler, testFilesInfo) {
        return (0, _asyncToGenerator3.default)(function* () {
            if (!compiler.canPrecompile) return;

            const precompiledCode = yield compiler.precompile(testFilesInfo);

            for (let i = 0; i < testFilesInfo.length; i++) testFilesInfo[i].compiledCode = precompiledCode[i];
        })();
    }

    _getCompilerTasks(testFilesInfo) {
        const tasks = new _weakMap2.default();
        const compilers = [];

        for (var _iterator = testFilesInfo, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            const info = _ref;
            const compiler = info.compiler;


            if (!tasks.has(compiler)) {
                compilers.push(compiler);
                tasks.set(compiler, []);
            }

            tasks.get(info.compiler).push(info);
        }

        return compilers.map(compiler => ({ compiler, compilerTestFilesInfo: tasks.get(compiler) }));
    }

    _getTests({ compiler, filename, code, compiledCode }) {
        return (0, _asyncToGenerator3.default)(function* () {
            if (compiledCode) return yield compiler.execute(compiledCode, filename);

            return yield compiler.compile(code, filename);
        })();
    }

    _compileTestFiles(filenames) {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            const testFilesInfo = yield _this2._createTestFilesInfo(filenames);
            const compilerTasks = _this2._getCompilerTasks(testFilesInfo);

            yield _pinkie2.default.all(compilerTasks.map(function ({ compiler, compilerTestFilesInfo }) {
                return _this2._precompileFiles(compiler, compilerTestFilesInfo);
            }));

            const tests = [];

            for (var _iterator2 = testFilesInfo, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
                var _ref2;

                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done) break;
                    _ref2 = _i2.value;
                }

                const info = _ref2;

                tests.push((yield _this2._getTests(info)));
            }return tests;
        })();
    }

    getTests() {
        var _this3 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            // NOTE: split sources into chunks because the fs module can't read all files
            // simultaneously if the number of them is too large (several thousands).
            const sourceChunks = (0, _lodash.chunk)(_this3.sources, SOURCE_CHUNK_LENGTH);

            let tests = [];

            while (sourceChunks.length) tests = tests.concat((yield _this3._compileTestFiles(sourceChunks.shift())));

            Compiler.cleanUp();

            return (0, _lodash.flattenDeep)(tests).filter(function (test) {
                return !!test;
            });
        })();
    }

    static cleanUp() {
        testFileCompilers.forEach(compiler => compiler.cleanUp());
    }
}
exports.default = Compiler;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21waWxlci9pbmRleC5qcyJdLCJuYW1lcyI6WyJTT1VSQ0VfQ0hVTktfTEVOR1RIIiwidGVzdEZpbGVDb21waWxlcnMiLCJMZWdhY3lUZXN0RmlsZUNvbXBpbGVyIiwiaGFtbWVyaGVhZCIsInByb2Nlc3NTY3JpcHQiLCJFc05leHRUZXN0RmlsZUNvbXBpbGVyIiwiVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIiLCJDb2ZmZWVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyIiwiUmF3VGVzdEZpbGVDb21waWxlciIsIkNvbXBpbGVyIiwiY29uc3RydWN0b3IiLCJzb3VyY2VzIiwiZ2V0U3VwcG9ydGVkVGVzdEZpbGVFeHRlbnNpb25zIiwibWFwIiwiY29tcGlsZXIiLCJnZXRTdXBwb3J0ZWRFeHRlbnNpb24iLCJfY3JlYXRlVGVzdEZpbGVJbmZvIiwiZmlsZW5hbWUiLCJjb2RlIiwiZXJyIiwiR2VuZXJhbEVycm9yIiwiUlVOVElNRV9FUlJPUlMiLCJjYW5ub3RGaW5kU3BlY2lmaWVkVGVzdFNvdXJjZSIsInRvU3RyaW5nIiwic29tZUNvbXBpbGVyIiwiY2FuQ29tcGlsZSIsImNvbXBpbGVkQ29kZSIsIl9jcmVhdGVUZXN0RmlsZXNJbmZvIiwiZmlsZW5hbWVzIiwidGVzdEZpbGVzSW5mbyIsIlByb21pc2UiLCJhbGwiLCJmaWx0ZXIiLCJpbmZvIiwiX3ByZWNvbXBpbGVGaWxlcyIsImNhblByZWNvbXBpbGUiLCJwcmVjb21waWxlZENvZGUiLCJwcmVjb21waWxlIiwiaSIsImxlbmd0aCIsIl9nZXRDb21waWxlclRhc2tzIiwidGFza3MiLCJjb21waWxlcnMiLCJoYXMiLCJwdXNoIiwic2V0IiwiZ2V0IiwiY29tcGlsZXJUZXN0RmlsZXNJbmZvIiwiX2dldFRlc3RzIiwiZXhlY3V0ZSIsImNvbXBpbGUiLCJfY29tcGlsZVRlc3RGaWxlcyIsImNvbXBpbGVyVGFza3MiLCJ0ZXN0cyIsImdldFRlc3RzIiwic291cmNlQ2h1bmtzIiwiY29uY2F0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QTs7QUFBQSxzQkFBV0ksSUFBWDs7QUFDSW9CLHNCQUFNVCxJQUFOLEVBQVcsTUFBTSxPQUFLSSxTQUFMLENBQWVmLElBQWYsQ0FBakI7QUFESixhQUdBLE9BQU9vQixLQUFQO0FBWGdDO0FBWW5DOztBQUVLQyxZQUFOLEdBQWtCO0FBQUE7O0FBQUE7QUFDZDtBQUNBO0FBQ0Esa0JBQU1DLGVBQWUsbUJBQU0sT0FBSzVDLE9BQVgsRUFBb0JYLG1CQUFwQixDQUFyQjs7QUFFQSxnQkFBSXFELFFBQVEsRUFBWjs7QUFFQSxtQkFBT0UsYUFBYWhCLE1BQXBCLEVBQ0ljLFFBQVFBLE1BQU1HLE1BQU4sRUFBYSxNQUFNLE9BQUtMLGlCQUFMLENBQXVCSSxhQUFhRSxLQUFiLEVBQXZCLENBQW5CLEVBQVI7O0FBRUpoRCxxQkFBU2lELE9BQVQ7O0FBRUEsbUJBQU8seUJBQVlMLEtBQVosRUFBbUJyQixNQUFuQixDQUEwQjtBQUFBLHVCQUFRLENBQUMsQ0FBQzJCLElBQVY7QUFBQSxhQUExQixDQUFQO0FBWmM7QUFhakI7O0FBRUQsV0FBT0QsT0FBUCxHQUFrQjtBQUNkekQsMEJBQWtCMkQsT0FBbEIsQ0FBMEI5QyxZQUFZQSxTQUFTNEMsT0FBVCxFQUF0QztBQUNIO0FBM0d5QjtrQkFBVGpELFEiLCJmaWxlIjoiY29tcGlsZXIvaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUHJvbWlzZSBmcm9tICdwaW5raWUnO1xuaW1wb3J0IHsgZmxhdHRlbkRlZXAsIGZpbmQsIGNodW5rLCB1bmlxIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBzdHJpcEJvbSBmcm9tICdzdHJpcC1ib20nO1xuaW1wb3J0IHsgQ29tcGlsZXIgYXMgTGVnYWN5VGVzdEZpbGVDb21waWxlciB9IGZyb20gJ3Rlc3RjYWZlLWxlZ2FjeS1hcGknO1xuaW1wb3J0IGhhbW1lcmhlYWQgZnJvbSAndGVzdGNhZmUtaGFtbWVyaGVhZCc7XG5pbXBvcnQgRXNOZXh0VGVzdEZpbGVDb21waWxlciBmcm9tICcuL3Rlc3QtZmlsZS9mb3JtYXRzL2VzLW5leHQvY29tcGlsZXInO1xuaW1wb3J0IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyIGZyb20gJy4vdGVzdC1maWxlL2Zvcm1hdHMvdHlwZXNjcmlwdC9jb21waWxlcic7XG5pbXBvcnQgQ29mZmVlU2NyaXB0VGVzdEZpbGVDb21waWxlciBmcm9tICcuL3Rlc3QtZmlsZS9mb3JtYXRzL2NvZmZlZXNjcmlwdC9jb21waWxlcic7XG5pbXBvcnQgUmF3VGVzdEZpbGVDb21waWxlciBmcm9tICcuL3Rlc3QtZmlsZS9mb3JtYXRzL3Jhdyc7XG5pbXBvcnQgeyByZWFkRmlsZSB9IGZyb20gJy4uL3V0aWxzL3Byb21pc2lmaWVkLWZ1bmN0aW9ucyc7XG5pbXBvcnQgeyBHZW5lcmFsRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvcnVudGltZSc7XG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uL2Vycm9ycy90eXBlcyc7XG5cblxuY29uc3QgU09VUkNFX0NIVU5LX0xFTkdUSCA9IDEwMDA7XG5cbmNvbnN0IHRlc3RGaWxlQ29tcGlsZXJzID0gW1xuICAgIG5ldyBMZWdhY3lUZXN0RmlsZUNvbXBpbGVyKGhhbW1lcmhlYWQucHJvY2Vzc1NjcmlwdCksXG4gICAgbmV3IEVzTmV4dFRlc3RGaWxlQ29tcGlsZXIoKSxcbiAgICBuZXcgVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIoKSxcbiAgICBuZXcgQ29mZmVlU2NyaXB0VGVzdEZpbGVDb21waWxlcigpLFxuICAgIG5ldyBSYXdUZXN0RmlsZUNvbXBpbGVyKClcbl07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBpbGVyIHtcbiAgICBjb25zdHJ1Y3RvciAoc291cmNlcykge1xuICAgICAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRTdXBwb3J0ZWRUZXN0RmlsZUV4dGVuc2lvbnMgKCkge1xuICAgICAgICByZXR1cm4gdW5pcSh0ZXN0RmlsZUNvbXBpbGVycy5tYXAoY29tcGlsZXIgPT4gY29tcGlsZXIuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9uKCkpKTtcbiAgICB9XG5cbiAgICBhc3luYyBfY3JlYXRlVGVzdEZpbGVJbmZvIChmaWxlbmFtZSkge1xuICAgICAgICBsZXQgY29kZSA9IG51bGw7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvZGUgPSBhd2FpdCByZWFkRmlsZShmaWxlbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdlbmVyYWxFcnJvcihSVU5USU1FX0VSUk9SUy5jYW5ub3RGaW5kU3BlY2lmaWVkVGVzdFNvdXJjZSwgZmlsZW5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IHN0cmlwQm9tKGNvZGUpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgY29uc3QgY29tcGlsZXIgPSBmaW5kKHRlc3RGaWxlQ29tcGlsZXJzLCBzb21lQ29tcGlsZXIgPT4gc29tZUNvbXBpbGVyLmNhbkNvbXBpbGUoY29kZSwgZmlsZW5hbWUpKTtcblxuICAgICAgICBpZiAoIWNvbXBpbGVyKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgIGNvbXBpbGVyLFxuXG4gICAgICAgICAgICBjb21waWxlZENvZGU6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBfY3JlYXRlVGVzdEZpbGVzSW5mbyAoZmlsZW5hbWVzKSB7XG4gICAgICAgIGNvbnN0IHRlc3RGaWxlc0luZm8gPSBhd2FpdCBQcm9taXNlLmFsbChmaWxlbmFtZXMubWFwKGZpbGVuYW1lID0+IHRoaXMuX2NyZWF0ZVRlc3RGaWxlSW5mbyhmaWxlbmFtZSkpKTtcblxuICAgICAgICByZXR1cm4gdGVzdEZpbGVzSW5mby5maWx0ZXIoaW5mbyA9PiAhIWluZm8pO1xuICAgIH1cblxuICAgIGFzeW5jIF9wcmVjb21waWxlRmlsZXMgKGNvbXBpbGVyLCB0ZXN0RmlsZXNJbmZvKSB7XG4gICAgICAgIGlmICghY29tcGlsZXIuY2FuUHJlY29tcGlsZSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjb25zdCBwcmVjb21waWxlZENvZGUgPSBhd2FpdCBjb21waWxlci5wcmVjb21waWxlKHRlc3RGaWxlc0luZm8pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVzdEZpbGVzSW5mby5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRlc3RGaWxlc0luZm9baV0uY29tcGlsZWRDb2RlID0gcHJlY29tcGlsZWRDb2RlW2ldO1xuICAgIH1cblxuICAgIF9nZXRDb21waWxlclRhc2tzICh0ZXN0RmlsZXNJbmZvKSB7XG4gICAgICAgIGNvbnN0IHRhc2tzICAgICA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIGNvbnN0IGNvbXBpbGVycyA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgaW5mbyBvZiB0ZXN0RmlsZXNJbmZvKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbXBpbGVyIH0gPSBpbmZvO1xuXG4gICAgICAgICAgICBpZiAoIXRhc2tzLmhhcyhjb21waWxlcikpIHtcbiAgICAgICAgICAgICAgICBjb21waWxlcnMucHVzaChjb21waWxlcik7XG4gICAgICAgICAgICAgICAgdGFza3Muc2V0KGNvbXBpbGVyLCBbXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhc2tzLmdldChpbmZvLmNvbXBpbGVyKS5wdXNoKGluZm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBpbGVycy5tYXAoY29tcGlsZXIgPT4gKHsgY29tcGlsZXIsIGNvbXBpbGVyVGVzdEZpbGVzSW5mbzogdGFza3MuZ2V0KGNvbXBpbGVyKSB9KSk7XG4gICAgfVxuXG4gICAgYXN5bmMgX2dldFRlc3RzICh7IGNvbXBpbGVyLCBmaWxlbmFtZSwgY29kZSwgY29tcGlsZWRDb2RlIH0pIHtcbiAgICAgICAgaWYgKGNvbXBpbGVkQ29kZSlcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBjb21waWxlci5leGVjdXRlKGNvbXBpbGVkQ29kZSwgZmlsZW5hbWUpO1xuXG4gICAgICAgIHJldHVybiBhd2FpdCBjb21waWxlci5jb21waWxlKGNvZGUsIGZpbGVuYW1lKTtcbiAgICB9XG5cbiAgICBhc3luYyBfY29tcGlsZVRlc3RGaWxlcyAoZmlsZW5hbWVzKSB7XG4gICAgICAgIGNvbnN0IHRlc3RGaWxlc0luZm8gPSBhd2FpdCB0aGlzLl9jcmVhdGVUZXN0RmlsZXNJbmZvKGZpbGVuYW1lcyk7XG4gICAgICAgIGNvbnN0IGNvbXBpbGVyVGFza3MgPSB0aGlzLl9nZXRDb21waWxlclRhc2tzKHRlc3RGaWxlc0luZm8pO1xuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNvbXBpbGVyVGFza3MubWFwKCh7IGNvbXBpbGVyLCBjb21waWxlclRlc3RGaWxlc0luZm8gfSkgPT4gdGhpcy5fcHJlY29tcGlsZUZpbGVzKGNvbXBpbGVyLCBjb21waWxlclRlc3RGaWxlc0luZm8pKSk7XG5cbiAgICAgICAgY29uc3QgdGVzdHMgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IGluZm8gb2YgdGVzdEZpbGVzSW5mbylcbiAgICAgICAgICAgIHRlc3RzLnB1c2goYXdhaXQgdGhpcy5fZ2V0VGVzdHMoaW5mbykpO1xuXG4gICAgICAgIHJldHVybiB0ZXN0cztcbiAgICB9XG5cbiAgICBhc3luYyBnZXRUZXN0cyAoKSB7XG4gICAgICAgIC8vIE5PVEU6IHNwbGl0IHNvdXJjZXMgaW50byBjaHVua3MgYmVjYXVzZSB0aGUgZnMgbW9kdWxlIGNhbid0IHJlYWQgYWxsIGZpbGVzXG4gICAgICAgIC8vIHNpbXVsdGFuZW91c2x5IGlmIHRoZSBudW1iZXIgb2YgdGhlbSBpcyB0b28gbGFyZ2UgKHNldmVyYWwgdGhvdXNhbmRzKS5cbiAgICAgICAgY29uc3Qgc291cmNlQ2h1bmtzID0gY2h1bmsodGhpcy5zb3VyY2VzLCBTT1VSQ0VfQ0hVTktfTEVOR1RIKTtcblxuICAgICAgICBsZXQgdGVzdHMgPSBbXTtcblxuICAgICAgICB3aGlsZSAoc291cmNlQ2h1bmtzLmxlbmd0aClcbiAgICAgICAgICAgIHRlc3RzID0gdGVzdHMuY29uY2F0KGF3YWl0IHRoaXMuX2NvbXBpbGVUZXN0RmlsZXMoc291cmNlQ2h1bmtzLnNoaWZ0KCkpKTtcblxuICAgICAgICBDb21waWxlci5jbGVhblVwKCk7XG5cbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5EZWVwKHRlc3RzKS5maWx0ZXIodGVzdCA9PiAhIXRlc3QpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjbGVhblVwICgpIHtcbiAgICAgICAgdGVzdEZpbGVDb21waWxlcnMuZm9yRWFjaChjb21waWxlciA9PiBjb21waWxlci5jbGVhblVwKCkpO1xuICAgIH1cbn1cbiJdfQ==
