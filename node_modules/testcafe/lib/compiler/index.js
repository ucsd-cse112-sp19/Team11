"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const pinkie_1 = __importDefault(require("pinkie"));
const lodash_1 = require("lodash");
const strip_bom_1 = __importDefault(require("strip-bom"));
const testcafe_legacy_api_1 = require("testcafe-legacy-api");
const testcafe_hammerhead_1 = __importDefault(require("testcafe-hammerhead"));
const compiler_1 = __importDefault(require("./test-file/formats/es-next/compiler"));
const compiler_2 = __importDefault(require("./test-file/formats/typescript/compiler"));
const compiler_3 = __importDefault(require("./test-file/formats/coffeescript/compiler"));
const raw_1 = __importDefault(require("./test-file/formats/raw"));
const promisified_functions_1 = require("../utils/promisified-functions");
const runtime_1 = require("../errors/runtime");
const types_1 = require("../errors/types");
const SOURCE_CHUNK_LENGTH = 1000;
const testFileCompilers = [
    new testcafe_legacy_api_1.Compiler(testcafe_hammerhead_1.default.processScript),
    new compiler_1.default(),
    new compiler_2.default(),
    new compiler_3.default(),
    new raw_1.default()
];
class Compiler {
    constructor(sources) {
        this.sources = sources;
    }
    static getSupportedTestFileExtensions() {
        return lodash_1.uniq(testFileCompilers.map(compiler => compiler.getSupportedExtension()));
    }
    async _createTestFileInfo(filename) {
        let code = null;
        try {
            code = await promisified_functions_1.readFile(filename);
        }
        catch (err) {
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.cannotFindSpecifiedTestSource, filename);
        }
        code = strip_bom_1.default(code).toString();
        const compiler = lodash_1.find(testFileCompilers, someCompiler => someCompiler.canCompile(code, filename));
        if (!compiler)
            return null;
        return {
            filename,
            code,
            compiler,
            compiledCode: null
        };
    }
    async _createTestFilesInfo(filenames) {
        const testFilesInfo = await pinkie_1.default.all(filenames.map(filename => this._createTestFileInfo(filename)));
        return testFilesInfo.filter(info => !!info);
    }
    async _precompileFiles(compiler, testFilesInfo) {
        if (!compiler.canPrecompile)
            return;
        const precompiledCode = await compiler.precompile(testFilesInfo);
        for (let i = 0; i < testFilesInfo.length; i++)
            testFilesInfo[i].compiledCode = precompiledCode[i];
    }
    _getCompilerTasks(testFilesInfo) {
        const tasks = new WeakMap();
        const compilers = [];
        for (const info of testFilesInfo) {
            const { compiler } = info;
            if (!tasks.has(compiler)) {
                compilers.push(compiler);
                tasks.set(compiler, []);
            }
            tasks.get(info.compiler).push(info);
        }
        return compilers.map(compiler => ({ compiler, compilerTestFilesInfo: tasks.get(compiler) }));
    }
    async _getTests({ compiler, filename, code, compiledCode }) {
        if (compiledCode)
            return await compiler.execute(compiledCode, filename);
        return await compiler.compile(code, filename);
    }
    async _compileTestFiles(filenames) {
        const testFilesInfo = await this._createTestFilesInfo(filenames);
        const compilerTasks = this._getCompilerTasks(testFilesInfo);
        await pinkie_1.default.all(compilerTasks.map(({ compiler, compilerTestFilesInfo }) => this._precompileFiles(compiler, compilerTestFilesInfo)));
        const tests = [];
        for (const info of testFilesInfo)
            tests.push(await this._getTests(info));
        return tests;
    }
    async getTests() {
        // NOTE: split sources into chunks because the fs module can't read all files
        // simultaneously if the number of them is too large (several thousands).
        const sourceChunks = lodash_1.chunk(this.sources, SOURCE_CHUNK_LENGTH);
        let tests = [];
        while (sourceChunks.length)
            tests = tests.concat(await this._compileTestFiles(sourceChunks.shift()));
        Compiler.cleanUp();
        return lodash_1.flattenDeep(tests).filter(test => !!test);
    }
    static cleanUp() {
        testFileCompilers.forEach(compiler => compiler.cleanUp());
    }
}
exports.default = Compiler;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvY29tcGlsZXIvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxvREFBNkI7QUFDN0IsbUNBQXdEO0FBQ3hELDBEQUFpQztBQUNqQyw2REFBeUU7QUFDekUsOEVBQTZDO0FBQzdDLG9GQUEwRTtBQUMxRSx1RkFBaUY7QUFDakYseUZBQXFGO0FBQ3JGLGtFQUEwRDtBQUMxRCwwRUFBMEQ7QUFDMUQsK0NBQWlEO0FBQ2pELDJDQUFpRDtBQUdqRCxNQUFNLG1CQUFtQixHQUFHLElBQUksQ0FBQztBQUVqQyxNQUFNLGlCQUFpQixHQUFHO0lBQ3RCLElBQUksOEJBQXNCLENBQUMsNkJBQVUsQ0FBQyxhQUFhLENBQUM7SUFDcEQsSUFBSSxrQkFBc0IsRUFBRTtJQUM1QixJQUFJLGtCQUEwQixFQUFFO0lBQ2hDLElBQUksa0JBQTRCLEVBQUU7SUFDbEMsSUFBSSxhQUFtQixFQUFFO0NBQzVCLENBQUM7QUFFRixNQUFxQixRQUFRO0lBQ3pCLFlBQWEsT0FBTztRQUNoQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztJQUMzQixDQUFDO0lBRUQsTUFBTSxDQUFDLDhCQUE4QjtRQUNqQyxPQUFPLGFBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDckYsQ0FBQztJQUVELEtBQUssQ0FBQyxtQkFBbUIsQ0FBRSxRQUFRO1FBQy9CLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztRQUVoQixJQUFJO1lBQ0EsSUFBSSxHQUFHLE1BQU0sZ0NBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNuQztRQUNELE9BQU8sR0FBRyxFQUFFO1lBQ1IsTUFBTSxJQUFJLHNCQUFZLENBQUMsc0JBQWMsQ0FBQyw2QkFBNkIsRUFBRSxRQUFRLENBQUMsQ0FBQztTQUNsRjtRQUVELElBQUksR0FBRyxtQkFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRWpDLE1BQU0sUUFBUSxHQUFHLGFBQUksQ0FBQyxpQkFBaUIsRUFBRSxZQUFZLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFFbEcsSUFBSSxDQUFDLFFBQVE7WUFDVCxPQUFPLElBQUksQ0FBQztRQUVoQixPQUFPO1lBQ0gsUUFBUTtZQUNSLElBQUk7WUFDSixRQUFRO1lBRVIsWUFBWSxFQUFFLElBQUk7U0FDckIsQ0FBQztJQUNOLENBQUM7SUFFRCxLQUFLLENBQUMsb0JBQW9CLENBQUUsU0FBUztRQUNqQyxNQUFNLGFBQWEsR0FBRyxNQUFNLGdCQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXZHLE9BQU8sYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQsS0FBSyxDQUFDLGdCQUFnQixDQUFFLFFBQVEsRUFBRSxhQUFhO1FBQzNDLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYTtZQUN2QixPQUFPO1FBRVgsTUFBTSxlQUFlLEdBQUcsTUFBTSxRQUFRLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRWpFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxhQUFhLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRTtZQUN6QyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxHQUFHLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRUQsaUJBQWlCLENBQUUsYUFBYTtRQUM1QixNQUFNLEtBQUssR0FBTyxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQ2hDLE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQztRQUVyQixLQUFLLE1BQU0sSUFBSSxJQUFJLGFBQWEsRUFBRTtZQUM5QixNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDO1lBRTFCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFO2dCQUN0QixTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUN6QixLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQzthQUMzQjtZQUVELEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN2QztRQUVELE9BQU8sU0FBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxRQUFRLEVBQUUscUJBQXFCLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNqRyxDQUFDO0lBRUQsS0FBSyxDQUFDLFNBQVMsQ0FBRSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRTtRQUN2RCxJQUFJLFlBQVk7WUFDWixPQUFPLE1BQU0sUUFBUSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFMUQsT0FBTyxNQUFNLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRCxLQUFLLENBQUMsaUJBQWlCLENBQUUsU0FBUztRQUM5QixNQUFNLGFBQWEsR0FBRyxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqRSxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFNUQsTUFBTSxnQkFBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxRQUFRLEVBQUUscUJBQXFCLEVBQUUsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV0SSxNQUFNLEtBQUssR0FBRyxFQUFFLENBQUM7UUFFakIsS0FBSyxNQUFNLElBQUksSUFBSSxhQUFhO1lBQzVCLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFFM0MsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztJQUVELEtBQUssQ0FBQyxRQUFRO1FBQ1YsNkVBQTZFO1FBQzdFLHlFQUF5RTtRQUN6RSxNQUFNLFlBQVksR0FBRyxjQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1FBRTlELElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztRQUVmLE9BQU8sWUFBWSxDQUFDLE1BQU07WUFDdEIsS0FBSyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztRQUU3RSxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFbkIsT0FBTyxvQkFBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQsTUFBTSxDQUFDLE9BQU87UUFDVixpQkFBaUIsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztJQUM5RCxDQUFDO0NBQ0o7QUE1R0QsMkJBNEdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFByb21pc2UgZnJvbSAncGlua2llJztcbmltcG9ydCB7IGZsYXR0ZW5EZWVwLCBmaW5kLCBjaHVuaywgdW5pcSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgc3RyaXBCb20gZnJvbSAnc3RyaXAtYm9tJztcbmltcG9ydCB7IENvbXBpbGVyIGFzIExlZ2FjeVRlc3RGaWxlQ29tcGlsZXIgfSBmcm9tICd0ZXN0Y2FmZS1sZWdhY3ktYXBpJztcbmltcG9ydCBoYW1tZXJoZWFkIGZyb20gJ3Rlc3RjYWZlLWhhbW1lcmhlYWQnO1xuaW1wb3J0IEVzTmV4dFRlc3RGaWxlQ29tcGlsZXIgZnJvbSAnLi90ZXN0LWZpbGUvZm9ybWF0cy9lcy1uZXh0L2NvbXBpbGVyJztcbmltcG9ydCBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlciBmcm9tICcuL3Rlc3QtZmlsZS9mb3JtYXRzL3R5cGVzY3JpcHQvY29tcGlsZXInO1xuaW1wb3J0IENvZmZlZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIgZnJvbSAnLi90ZXN0LWZpbGUvZm9ybWF0cy9jb2ZmZWVzY3JpcHQvY29tcGlsZXInO1xuaW1wb3J0IFJhd1Rlc3RGaWxlQ29tcGlsZXIgZnJvbSAnLi90ZXN0LWZpbGUvZm9ybWF0cy9yYXcnO1xuaW1wb3J0IHsgcmVhZEZpbGUgfSBmcm9tICcuLi91dGlscy9wcm9taXNpZmllZC1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgR2VuZXJhbEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3J1bnRpbWUnO1xuaW1wb3J0IHsgUlVOVElNRV9FUlJPUlMgfSBmcm9tICcuLi9lcnJvcnMvdHlwZXMnO1xuXG5cbmNvbnN0IFNPVVJDRV9DSFVOS19MRU5HVEggPSAxMDAwO1xuXG5jb25zdCB0ZXN0RmlsZUNvbXBpbGVycyA9IFtcbiAgICBuZXcgTGVnYWN5VGVzdEZpbGVDb21waWxlcihoYW1tZXJoZWFkLnByb2Nlc3NTY3JpcHQpLFxuICAgIG5ldyBFc05leHRUZXN0RmlsZUNvbXBpbGVyKCksXG4gICAgbmV3IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyKCksXG4gICAgbmV3IENvZmZlZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIoKSxcbiAgICBuZXcgUmF3VGVzdEZpbGVDb21waWxlcigpXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21waWxlciB7XG4gICAgY29uc3RydWN0b3IgKHNvdXJjZXMpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0U3VwcG9ydGVkVGVzdEZpbGVFeHRlbnNpb25zICgpIHtcbiAgICAgICAgcmV0dXJuIHVuaXEodGVzdEZpbGVDb21waWxlcnMubWFwKGNvbXBpbGVyID0+IGNvbXBpbGVyLmdldFN1cHBvcnRlZEV4dGVuc2lvbigpKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgX2NyZWF0ZVRlc3RGaWxlSW5mbyAoZmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IGNvZGUgPSBudWxsO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb2RlID0gYXdhaXQgcmVhZEZpbGUoZmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMuY2Fubm90RmluZFNwZWNpZmllZFRlc3RTb3VyY2UsIGZpbGVuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSBzdHJpcEJvbShjb2RlKS50b1N0cmluZygpO1xuXG4gICAgICAgIGNvbnN0IGNvbXBpbGVyID0gZmluZCh0ZXN0RmlsZUNvbXBpbGVycywgc29tZUNvbXBpbGVyID0+IHNvbWVDb21waWxlci5jYW5Db21waWxlKGNvZGUsIGZpbGVuYW1lKSk7XG5cbiAgICAgICAgaWYgKCFjb21waWxlcilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICBjb21waWxlcixcblxuICAgICAgICAgICAgY29tcGlsZWRDb2RlOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgX2NyZWF0ZVRlc3RGaWxlc0luZm8gKGZpbGVuYW1lcykge1xuICAgICAgICBjb25zdCB0ZXN0RmlsZXNJbmZvID0gYXdhaXQgUHJvbWlzZS5hbGwoZmlsZW5hbWVzLm1hcChmaWxlbmFtZSA9PiB0aGlzLl9jcmVhdGVUZXN0RmlsZUluZm8oZmlsZW5hbWUpKSk7XG5cbiAgICAgICAgcmV0dXJuIHRlc3RGaWxlc0luZm8uZmlsdGVyKGluZm8gPT4gISFpbmZvKTtcbiAgICB9XG5cbiAgICBhc3luYyBfcHJlY29tcGlsZUZpbGVzIChjb21waWxlciwgdGVzdEZpbGVzSW5mbykge1xuICAgICAgICBpZiAoIWNvbXBpbGVyLmNhblByZWNvbXBpbGUpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY29uc3QgcHJlY29tcGlsZWRDb2RlID0gYXdhaXQgY29tcGlsZXIucHJlY29tcGlsZSh0ZXN0RmlsZXNJbmZvKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlc3RGaWxlc0luZm8ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0ZXN0RmlsZXNJbmZvW2ldLmNvbXBpbGVkQ29kZSA9IHByZWNvbXBpbGVkQ29kZVtpXTtcbiAgICB9XG5cbiAgICBfZ2V0Q29tcGlsZXJUYXNrcyAodGVzdEZpbGVzSW5mbykge1xuICAgICAgICBjb25zdCB0YXNrcyAgICAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICBjb25zdCBjb21waWxlcnMgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IGluZm8gb2YgdGVzdEZpbGVzSW5mbykge1xuICAgICAgICAgICAgY29uc3QgeyBjb21waWxlciB9ID0gaW5mbztcblxuICAgICAgICAgICAgaWYgKCF0YXNrcy5oYXMoY29tcGlsZXIpKSB7XG4gICAgICAgICAgICAgICAgY29tcGlsZXJzLnB1c2goY29tcGlsZXIpO1xuICAgICAgICAgICAgICAgIHRhc2tzLnNldChjb21waWxlciwgW10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXNrcy5nZXQoaW5mby5jb21waWxlcikucHVzaChpbmZvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21waWxlcnMubWFwKGNvbXBpbGVyID0+ICh7IGNvbXBpbGVyLCBjb21waWxlclRlc3RGaWxlc0luZm86IHRhc2tzLmdldChjb21waWxlcikgfSkpO1xuICAgIH1cblxuICAgIGFzeW5jIF9nZXRUZXN0cyAoeyBjb21waWxlciwgZmlsZW5hbWUsIGNvZGUsIGNvbXBpbGVkQ29kZSB9KSB7XG4gICAgICAgIGlmIChjb21waWxlZENvZGUpXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgY29tcGlsZXIuZXhlY3V0ZShjb21waWxlZENvZGUsIGZpbGVuYW1lKTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgY29tcGlsZXIuY29tcGlsZShjb2RlLCBmaWxlbmFtZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgX2NvbXBpbGVUZXN0RmlsZXMgKGZpbGVuYW1lcykge1xuICAgICAgICBjb25zdCB0ZXN0RmlsZXNJbmZvID0gYXdhaXQgdGhpcy5fY3JlYXRlVGVzdEZpbGVzSW5mbyhmaWxlbmFtZXMpO1xuICAgICAgICBjb25zdCBjb21waWxlclRhc2tzID0gdGhpcy5fZ2V0Q29tcGlsZXJUYXNrcyh0ZXN0RmlsZXNJbmZvKTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjb21waWxlclRhc2tzLm1hcCgoeyBjb21waWxlciwgY29tcGlsZXJUZXN0RmlsZXNJbmZvIH0pID0+IHRoaXMuX3ByZWNvbXBpbGVGaWxlcyhjb21waWxlciwgY29tcGlsZXJUZXN0RmlsZXNJbmZvKSkpO1xuXG4gICAgICAgIGNvbnN0IHRlc3RzID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCBpbmZvIG9mIHRlc3RGaWxlc0luZm8pXG4gICAgICAgICAgICB0ZXN0cy5wdXNoKGF3YWl0IHRoaXMuX2dldFRlc3RzKGluZm8pKTtcblxuICAgICAgICByZXR1cm4gdGVzdHM7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0VGVzdHMgKCkge1xuICAgICAgICAvLyBOT1RFOiBzcGxpdCBzb3VyY2VzIGludG8gY2h1bmtzIGJlY2F1c2UgdGhlIGZzIG1vZHVsZSBjYW4ndCByZWFkIGFsbCBmaWxlc1xuICAgICAgICAvLyBzaW11bHRhbmVvdXNseSBpZiB0aGUgbnVtYmVyIG9mIHRoZW0gaXMgdG9vIGxhcmdlIChzZXZlcmFsIHRob3VzYW5kcykuXG4gICAgICAgIGNvbnN0IHNvdXJjZUNodW5rcyA9IGNodW5rKHRoaXMuc291cmNlcywgU09VUkNFX0NIVU5LX0xFTkdUSCk7XG5cbiAgICAgICAgbGV0IHRlc3RzID0gW107XG5cbiAgICAgICAgd2hpbGUgKHNvdXJjZUNodW5rcy5sZW5ndGgpXG4gICAgICAgICAgICB0ZXN0cyA9IHRlc3RzLmNvbmNhdChhd2FpdCB0aGlzLl9jb21waWxlVGVzdEZpbGVzKHNvdXJjZUNodW5rcy5zaGlmdCgpKSk7XG5cbiAgICAgICAgQ29tcGlsZXIuY2xlYW5VcCgpO1xuXG4gICAgICAgIHJldHVybiBmbGF0dGVuRGVlcCh0ZXN0cykuZmlsdGVyKHRlc3QgPT4gISF0ZXN0KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xlYW5VcCAoKSB7XG4gICAgICAgIHRlc3RGaWxlQ29tcGlsZXJzLmZvckVhY2goY29tcGlsZXIgPT4gY29tcGlsZXIuY2xlYW5VcCgpKTtcbiAgICB9XG59XG4iXX0=