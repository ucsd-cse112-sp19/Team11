'use strict';

exports.__esModule = true;

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lodash = require('lodash');

var _osFamily = require('os-family');

var _osFamily2 = _interopRequireDefault(_osFamily);

var _apiBased = require('../../api-based');

var _apiBased2 = _interopRequireDefault(_apiBased);

var _compiler = require('../es-next/compiler');

var _compiler2 = _interopRequireDefault(_compiler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const RENAMED_DEPENDENCIES_MAP = new _map2.default([['testcafe', _apiBased2.default.EXPORTABLE_LIB_PATH]]);

class TypeScriptTestFileCompiler extends _apiBased2.default {
    static _getTypescriptOptions() {
        // NOTE: lazy load the compiler
        const ts = require('typescript');

        return {
            experimentalDecorators: true,
            emitDecoratorMetadata: true,
            allowJs: true,
            pretty: true,
            inlineSourceMap: true,
            noImplicitAny: false,
            module: ts.ModuleKind.CommonJS,
            target: 2 /* ES6 */
            , lib: ['lib.es6.d.ts'],
            baseUrl: __dirname,
            paths: { testcafe: ['../../../../../ts-defs/index.d.ts'] },
            suppressOutputPathCheck: true,
            skipLibCheck: true
        };
    }

    static _reportErrors(diagnostics) {
        // NOTE: lazy load the compiler
        const ts = require('typescript');
        let errMsg = 'TypeScript compilation failed.\n';

        diagnostics.forEach(d => {
            const file = d.file;

            var _file$getLineAndChara = file.getLineAndCharacterOfPosition(d.start);

            const line = _file$getLineAndChara.line,
                  character = _file$getLineAndChara.character;

            const message = ts.flattenDiagnosticMessageText(d.messageText, '\n');

            errMsg += `${file.fileName} (${line + 1}, ${character + 1}): ${message}\n`;
        });

        throw new Error(errMsg);
    }

    static _normalizeFilename(filename) {
        filename = _path2.default.resolve(filename);

        if (_osFamily2.default.win) filename = filename.toLowerCase();

        return filename;
    }

    _precompileCode(testFilesInfo) {
        // NOTE: lazy load the compiler
        const ts = require('typescript');

        const filenames = testFilesInfo.map(({ filename }) => filename);
        const normalizedFilenames = filenames.map(filename => TypeScriptTestFileCompiler._normalizeFilename(filename));
        const normalizedFilenamesMap = (0, _lodash.zipObject)(normalizedFilenames, filenames);

        const uncachedFiles = normalizedFilenames.filter(filename => !this.cache[filename]).map(filename => normalizedFilenamesMap[filename]);

        const opts = TypeScriptTestFileCompiler._getTypescriptOptions();
        const program = ts.createProgram(uncachedFiles, opts);

        program.getSourceFiles().forEach(sourceFile => {
            sourceFile.renamedDependencies = RENAMED_DEPENDENCIES_MAP;
        });

        const diagnostics = ts.getPreEmitDiagnostics(program);

        if (diagnostics.length) TypeScriptTestFileCompiler._reportErrors(diagnostics);

        // NOTE: The first argument of emit() is a source file to be compiled. If it's undefined, all files in
        // <program> will be compiled. <program> contains a file specified in createProgram() plus all its dependencies.
        // This mode is much faster than compiling files one-by-one, and it is used in the tsc CLI compiler.
        program.emit(void 0, (outputName, result, writeBOM, onError, sources) => {
            const sourcePath = TypeScriptTestFileCompiler._normalizeFilename(sources[0].fileName);

            this.cache[sourcePath] = result;
        });

        return normalizedFilenames.map(filename => this.cache[filename]);
    }

    _getRequireCompilers() {
        return {
            '.ts': (code, filename) => this._compileCode(code, filename),
            '.js': (code, filename) => _compiler2.default.prototype._compileCode.call(this, code, filename)
        };
    }

    get canPrecompile() {
        return true;
    }

    getSupportedExtension() {
        return '.ts';
    }
}
exports.default = TypeScriptTestFileCompiler;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21waWxlci90ZXN0LWZpbGUvZm9ybWF0cy90eXBlc2NyaXB0L2NvbXBpbGVyLmpzIl0sIm5hbWVzIjpbIlJFTkFNRURfREVQRU5ERU5DSUVTX01BUCIsIkFQSUJhc2VkVGVzdEZpbGVDb21waWxlckJhc2UiLCJFWFBPUlRBQkxFX0xJQl9QQVRIIiwiVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIiLCJfZ2V0VHlwZXNjcmlwdE9wdGlvbnMiLCJ0cyIsInJlcXVpcmUiLCJleHBlcmltZW50YWxEZWNvcmF0b3JzIiwiZW1pdERlY29yYXRvck1ldGFkYXRhIiwiYWxsb3dKcyIsInByZXR0eSIsImlubGluZVNvdXJjZU1hcCIsIm5vSW1wbGljaXRBbnkiLCJtb2R1bGUiLCJNb2R1bGVLaW5kIiwiQ29tbW9uSlMiLCJ0YXJnZXQiLCJsaWIiLCJiYXNlVXJsIiwiX19kaXJuYW1lIiwicGF0aHMiLCJ0ZXN0Y2FmZSIsInN1cHByZXNzT3V0cHV0UGF0aENoZWNrIiwic2tpcExpYkNoZWNrIiwiX3JlcG9ydEVycm9ycyIsImRpYWdub3N0aWNzIiwiZXJyTXNnIiwiZm9yRWFjaCIsImQiLCJmaWxlIiwiZ2V0TGluZUFuZENoYXJhY3Rlck9mUG9zaXRpb24iLCJzdGFydCIsImxpbmUiLCJjaGFyYWN0ZXIiLCJtZXNzYWdlIiwiZmxhdHRlbkRpYWdub3N0aWNNZXNzYWdlVGV4dCIsIm1lc3NhZ2VUZXh0IiwiZmlsZU5hbWUiLCJFcnJvciIsIl9ub3JtYWxpemVGaWxlbmFtZSIsImZpbGVuYW1lIiwicGF0aCIsInJlc29sdmUiLCJPUyIsIndpbiIsInRvTG93ZXJDYXNlIiwiX3ByZWNvbXBpbGVDb2RlIiwidGVzdEZpbGVzSW5mbyIsImZpbGVuYW1lcyIsIm1hcCIsIm5vcm1hbGl6ZWRGaWxlbmFtZXMiLCJub3JtYWxpemVkRmlsZW5hbWVzTWFwIiwidW5jYWNoZWRGaWxlcyIsImZpbHRlciIsImNhY2hlIiwib3B0cyIsInByb2dyYW0iLCJjcmVhdGVQcm9ncmFtIiwiZ2V0U291cmNlRmlsZXMiLCJzb3VyY2VGaWxlIiwicmVuYW1lZERlcGVuZGVuY2llcyIsImdldFByZUVtaXREaWFnbm9zdGljcyIsImxlbmd0aCIsImVtaXQiLCJvdXRwdXROYW1lIiwicmVzdWx0Iiwid3JpdGVCT00iLCJvbkVycm9yIiwic291cmNlcyIsInNvdXJjZVBhdGgiLCJfZ2V0UmVxdWlyZUNvbXBpbGVycyIsImNvZGUiLCJfY29tcGlsZUNvZGUiLCJFU05leHRUZXN0RmlsZUNvbXBpbGVyIiwicHJvdG90eXBlIiwiY2FsbCIsImNhblByZWNvbXBpbGUiLCJnZXRTdXBwb3J0ZWRFeHRlbnNpb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUdBLE1BQU1BLDJCQUEyQixrQkFBUSxDQUFDLENBQUMsVUFBRCxFQUFhQyxtQkFBNkJDLG1CQUExQyxDQUFELENBQVIsQ0FBakM7O0FBRWUsTUFBTUMsMEJBQU4sU0FBeUNGLGtCQUF6QyxDQUFzRTtBQUNqRixXQUFPRyxxQkFBUCxHQUFnQztBQUM1QjtBQUNBLGNBQU1DLEtBQUtDLFFBQVEsWUFBUixDQUFYOztBQUVBLGVBQU87QUFDSEMsb0NBQXlCLElBRHRCO0FBRUhDLG1DQUF5QixJQUZ0QjtBQUdIQyxxQkFBeUIsSUFIdEI7QUFJSEMsb0JBQXlCLElBSnRCO0FBS0hDLDZCQUF5QixJQUx0QjtBQU1IQywyQkFBeUIsS0FOdEI7QUFPSEMsb0JBQXlCUixHQUFHUyxVQUFILENBQWNDLFFBUHBDO0FBUUhDLG9CQUF5QixDQVJ0QixDQVF3QjtBQVJ4QixjQVNIQyxLQUF5QixDQUFDLGNBQUQsQ0FUdEI7QUFVSEMscUJBQXlCQyxTQVZ0QjtBQVdIQyxtQkFBeUIsRUFBRUMsVUFBVSxDQUFDLG1DQUFELENBQVosRUFYdEI7QUFZSEMscUNBQXlCLElBWnRCO0FBYUhDLDBCQUF5QjtBQWJ0QixTQUFQO0FBZUg7O0FBRUQsV0FBT0MsYUFBUCxDQUFzQkMs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LFNBQXZCLENBQWlDRixZQUFqQyxDQUE4Q0csSUFBOUMsQ0FBbUQsSUFBbkQsRUFBeURKLElBQXpELEVBQStEL0IsUUFBL0Q7QUFGeEIsU0FBUDtBQUlIOztBQUVELFFBQUlvQyxhQUFKLEdBQXFCO0FBQ2pCLGVBQU8sSUFBUDtBQUNIOztBQUVEQyw0QkFBeUI7QUFDckIsZUFBTyxLQUFQO0FBQ0g7QUFoR2dGO2tCQUFoRTFFLDBCIiwiZmlsZSI6ImNvbXBpbGVyL3Rlc3QtZmlsZS9mb3JtYXRzL3R5cGVzY3JpcHQvY29tcGlsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHppcE9iamVjdCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgT1MgZnJvbSAnb3MtZmFtaWx5JztcbmltcG9ydCBBUElCYXNlZFRlc3RGaWxlQ29tcGlsZXJCYXNlIGZyb20gJy4uLy4uL2FwaS1iYXNlZCc7XG5pbXBvcnQgRVNOZXh0VGVzdEZpbGVDb21waWxlciBmcm9tICcuLi9lcy1uZXh0L2NvbXBpbGVyJztcblxuXG5jb25zdCBSRU5BTUVEX0RFUEVOREVOQ0lFU19NQVAgPSBuZXcgTWFwKFtbJ3Rlc3RjYWZlJywgQVBJQmFzZWRUZXN0RmlsZUNvbXBpbGVyQmFzZS5FWFBPUlRBQkxFX0xJQl9QQVRIXV0pO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlciBleHRlbmRzIEFQSUJhc2VkVGVzdEZpbGVDb21waWxlckJhc2Uge1xuICAgIHN0YXRpYyBfZ2V0VHlwZXNjcmlwdE9wdGlvbnMgKCkge1xuICAgICAgICAvLyBOT1RFOiBsYXp5IGxvYWQgdGhlIGNvbXBpbGVyXG4gICAgICAgIGNvbnN0IHRzID0gcmVxdWlyZSgndHlwZXNjcmlwdCcpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBleHBlcmltZW50YWxEZWNvcmF0b3JzOiAgdHJ1ZSxcbiAgICAgICAgICAgIGVtaXREZWNvcmF0b3JNZXRhZGF0YTogICB0cnVlLFxuICAgICAgICAgICAgYWxsb3dKczogICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBwcmV0dHk6ICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIGlubGluZVNvdXJjZU1hcDogICAgICAgICB0cnVlLFxuICAgICAgICAgICAgbm9JbXBsaWNpdEFueTogICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgbW9kdWxlOiAgICAgICAgICAgICAgICAgIHRzLk1vZHVsZUtpbmQuQ29tbW9uSlMsXG4gICAgICAgICAgICB0YXJnZXQ6ICAgICAgICAgICAgICAgICAgMiAvKiBFUzYgKi8sXG4gICAgICAgICAgICBsaWI6ICAgICAgICAgICAgICAgICAgICAgWydsaWIuZXM2LmQudHMnXSxcbiAgICAgICAgICAgIGJhc2VVcmw6ICAgICAgICAgICAgICAgICBfX2Rpcm5hbWUsXG4gICAgICAgICAgICBwYXRoczogICAgICAgICAgICAgICAgICAgeyB0ZXN0Y2FmZTogWycuLi8uLi8uLi8uLi8uLi90cy1kZWZzL2luZGV4LmQudHMnXSB9LFxuICAgICAgICAgICAgc3VwcHJlc3NPdXRwdXRQYXRoQ2hlY2s6IHRydWUsXG4gICAgICAgICAgICBza2lwTGliQ2hlY2s6ICAgICAgICAgICAgdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyBfcmVwb3J0RXJyb3JzIChkaWFnbm9zdGljcykge1xuICAgICAgICAvLyBOT1RFOiBsYXp5IGxvYWQgdGhlIGNvbXBpbGVyXG4gICAgICAgIGNvbnN0IHRzICAgICA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQnKTtcbiAgICAgICAgbGV0IGVyck1zZyA9ICdUeXBlU2NyaXB0IGNvbXBpbGF0aW9uIGZhaWxlZC5cXG4nO1xuXG4gICAgICAgIGRpYWdub3N0aWNzLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlICAgICAgICAgICAgICAgID0gZC5maWxlO1xuICAgICAgICAgICAgY29uc3QgeyBsaW5lLCBjaGFyYWN0ZXIgfSA9IGZpbGUuZ2V0TGluZUFuZENoYXJhY3Rlck9mUG9zaXRpb24oZC5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlICAgICAgICAgICAgID0gdHMuZmxhdHRlbkRpYWdub3N0aWNNZXNzYWdlVGV4dChkLm1lc3NhZ2VUZXh0LCAnXFxuJyk7XG5cbiAgICAgICAgICAgIGVyck1zZyArPSBgJHtmaWxlLmZpbGVOYW1lfSAoJHtsaW5lICsgMX0sICR7Y2hhcmFjdGVyICsgMX0pOiAke21lc3NhZ2V9XFxuYDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgfVxuXG4gICAgc3RhdGljIF9ub3JtYWxpemVGaWxlbmFtZSAoZmlsZW5hbWUpIHtcbiAgICAgICAgZmlsZW5hbWUgPSBwYXRoLnJlc29sdmUoZmlsZW5hbWUpO1xuXG4gICAgICAgIGlmIChPUy53aW4pXG4gICAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cblxuICAgIF9wcmVjb21waWxlQ29kZSAodGVzdEZpbGVzSW5mbykge1xuICAgICAgICAvLyBOT1RFOiBsYXp5IGxvYWQgdGhlIGNvbXBpbGVyXG4gICAgICAgIGNvbnN0IHRzID0gcmVxdWlyZSgndHlwZXNjcmlwdCcpO1xuXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lcyAgICAgICAgICAgICAgPSB0ZXN0RmlsZXNJbmZvLm1hcCgoeyBmaWxlbmFtZSB9KSA9PiBmaWxlbmFtZSk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGaWxlbmFtZXMgICAgPSBmaWxlbmFtZXMubWFwKGZpbGVuYW1lID0+IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9ub3JtYWxpemVGaWxlbmFtZShmaWxlbmFtZSkpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkRmlsZW5hbWVzTWFwID0gemlwT2JqZWN0KG5vcm1hbGl6ZWRGaWxlbmFtZXMsIGZpbGVuYW1lcyk7XG5cbiAgICAgICAgY29uc3QgdW5jYWNoZWRGaWxlcyA9IG5vcm1hbGl6ZWRGaWxlbmFtZXNcbiAgICAgICAgICAgIC5maWx0ZXIoZmlsZW5hbWUgPT4gIXRoaXMuY2FjaGVbZmlsZW5hbWVdKVxuICAgICAgICAgICAgLm1hcChmaWxlbmFtZSA9PiBub3JtYWxpemVkRmlsZW5hbWVzTWFwW2ZpbGVuYW1lXSk7XG5cbiAgICAgICAgY29uc3Qgb3B0cyAgICA9IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9nZXRUeXBlc2NyaXB0T3B0aW9ucygpO1xuICAgICAgICBjb25zdCBwcm9ncmFtID0gdHMuY3JlYXRlUHJvZ3JhbSh1bmNhY2hlZEZpbGVzLCBvcHRzKTtcblxuICAgICAgICBwcm9ncmFtLmdldFNvdXJjZUZpbGVzKCkuZm9yRWFjaChzb3VyY2VGaWxlID0+IHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUucmVuYW1lZERlcGVuZGVuY2llcyA9IFJFTkFNRURfREVQRU5ERU5DSUVTX01BUDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZGlhZ25vc3RpY3MgPSB0cy5nZXRQcmVFbWl0RGlhZ25vc3RpY3MocHJvZ3JhbSk7XG5cbiAgICAgICAgaWYgKGRpYWdub3N0aWNzLmxlbmd0aClcbiAgICAgICAgICAgIFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9yZXBvcnRFcnJvcnMoZGlhZ25vc3RpY3MpO1xuXG4gICAgICAgIC8vIE5PVEU6IFRoZSBmaXJzdCBhcmd1bWVudCBvZiBlbWl0KCkgaXMgYSBzb3VyY2UgZmlsZSB0byBiZSBjb21waWxlZC4gSWYgaXQncyB1bmRlZmluZWQsIGFsbCBmaWxlcyBpblxuICAgICAgICAvLyA8cHJvZ3JhbT4gd2lsbCBiZSBjb21waWxlZC4gPHByb2dyYW0+IGNvbnRhaW5zIGEgZmlsZSBzcGVjaWZpZWQgaW4gY3JlYXRlUHJvZ3JhbSgpIHBsdXMgYWxsIGl0cyBkZXBlbmRlbmNpZXMuXG4gICAgICAgIC8vIFRoaXMgbW9kZSBpcyBtdWNoIGZhc3RlciB0aGFuIGNvbXBpbGluZyBmaWxlcyBvbmUtYnktb25lLCBhbmQgaXQgaXMgdXNlZCBpbiB0aGUgdHNjIENMSSBjb21waWxlci5cbiAgICAgICAgcHJvZ3JhbS5lbWl0KHZvaWQgMCwgKG91dHB1dE5hbWUsIHJlc3VsdCwgd3JpdGVCT00sIG9uRXJyb3IsIHNvdXJjZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBhdGggPSBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlci5fbm9ybWFsaXplRmlsZW5hbWUoc291cmNlc1swXS5maWxlTmFtZSk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVbc291cmNlUGF0aF0gPSByZXN1bHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkRmlsZW5hbWVzLm1hcChmaWxlbmFtZSA9PiB0aGlzLmNhY2hlW2ZpbGVuYW1lXSk7XG4gICAgfVxuXG4gICAgX2dldFJlcXVpcmVDb21waWxlcnMgKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJy50cyc6IChjb2RlLCBmaWxlbmFtZSkgPT4gdGhpcy5fY29tcGlsZUNvZGUoY29kZSwgZmlsZW5hbWUpLFxuICAgICAgICAgICAgJy5qcyc6IChjb2RlLCBmaWxlbmFtZSkgPT4gRVNOZXh0VGVzdEZpbGVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb2RlLmNhbGwodGhpcywgY29kZSwgZmlsZW5hbWUpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0IGNhblByZWNvbXBpbGUgKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBnZXRTdXBwb3J0ZWRFeHRlbnNpb24gKCkge1xuICAgICAgICByZXR1cm4gJy50cyc7XG4gICAgfVxufVxuIl19
