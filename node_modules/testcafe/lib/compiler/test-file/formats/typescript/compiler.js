"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const lodash_1 = require("lodash");
const os_family_1 = __importDefault(require("os-family"));
const api_based_1 = __importDefault(require("../../api-based"));
const compiler_1 = __importDefault(require("../es-next/compiler"));
const RENAMED_DEPENDENCIES_MAP = new Map([['testcafe', api_based_1.default.EXPORTABLE_LIB_PATH]]);
class TypeScriptTestFileCompiler extends api_based_1.default {
    static _getTypescriptOptions() {
        // NOTE: lazy load the compiler
        const ts = require('typescript');
        return {
            experimentalDecorators: true,
            emitDecoratorMetadata: true,
            allowJs: true,
            pretty: true,
            inlineSourceMap: true,
            noImplicitAny: false,
            module: ts.ModuleKind.CommonJS,
            target: 2 /* ES6 */,
            lib: ['lib.es6.d.ts'],
            baseUrl: __dirname,
            paths: { testcafe: ['../../../../../ts-defs/index.d.ts'] },
            suppressOutputPathCheck: true,
            skipLibCheck: true
        };
    }
    static _reportErrors(diagnostics) {
        // NOTE: lazy load the compiler
        const ts = require('typescript');
        let errMsg = 'TypeScript compilation failed.\n';
        diagnostics.forEach(d => {
            const file = d.file;
            const { line, character } = file.getLineAndCharacterOfPosition(d.start);
            const message = ts.flattenDiagnosticMessageText(d.messageText, '\n');
            errMsg += `${file.fileName} (${line + 1}, ${character + 1}): ${message}\n`;
        });
        throw new Error(errMsg);
    }
    static _normalizeFilename(filename) {
        filename = path_1.default.resolve(filename);
        if (os_family_1.default.win)
            filename = filename.toLowerCase();
        return filename;
    }
    _precompileCode(testFilesInfo) {
        // NOTE: lazy load the compiler
        const ts = require('typescript');
        const filenames = testFilesInfo.map(({ filename }) => filename);
        const normalizedFilenames = filenames.map(filename => TypeScriptTestFileCompiler._normalizeFilename(filename));
        const normalizedFilenamesMap = lodash_1.zipObject(normalizedFilenames, filenames);
        const uncachedFiles = normalizedFilenames
            .filter(filename => !this.cache[filename])
            .map(filename => normalizedFilenamesMap[filename]);
        const opts = TypeScriptTestFileCompiler._getTypescriptOptions();
        const program = ts.createProgram(uncachedFiles, opts);
        program.getSourceFiles().forEach(sourceFile => {
            sourceFile.renamedDependencies = RENAMED_DEPENDENCIES_MAP;
        });
        const diagnostics = ts.getPreEmitDiagnostics(program);
        if (diagnostics.length)
            TypeScriptTestFileCompiler._reportErrors(diagnostics);
        // NOTE: The first argument of emit() is a source file to be compiled. If it's undefined, all files in
        // <program> will be compiled. <program> contains a file specified in createProgram() plus all its dependencies.
        // This mode is much faster than compiling files one-by-one, and it is used in the tsc CLI compiler.
        program.emit(void 0, (outputName, result, writeBOM, onError, sources) => {
            const sourcePath = TypeScriptTestFileCompiler._normalizeFilename(sources[0].fileName);
            this.cache[sourcePath] = result;
        });
        return normalizedFilenames.map(filename => this.cache[filename]);
    }
    _getRequireCompilers() {
        return {
            '.ts': (code, filename) => this._compileCode(code, filename),
            '.js': (code, filename) => compiler_1.default.prototype._compileCode.call(this, code, filename)
        };
    }
    get canPrecompile() {
        return true;
    }
    getSupportedExtension() {
        return '.ts';
    }
}
exports.default = TypeScriptTestFileCompiler;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29tcGlsZXIvdGVzdC1maWxlL2Zvcm1hdHMvdHlwZXNjcmlwdC9jb21waWxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdEQUF3QjtBQUN4QixtQ0FBbUM7QUFDbkMsMERBQTJCO0FBQzNCLGdFQUEyRDtBQUMzRCxtRUFBeUQ7QUFHekQsTUFBTSx3QkFBd0IsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFLG1CQUE0QixDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDO0FBRTNHLE1BQXFCLDBCQUEyQixTQUFRLG1CQUE0QjtJQUNoRixNQUFNLENBQUMscUJBQXFCO1FBQ3hCLCtCQUErQjtRQUMvQixNQUFNLEVBQUUsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFakMsT0FBTztZQUNILHNCQUFzQixFQUFHLElBQUk7WUFDN0IscUJBQXFCLEVBQUksSUFBSTtZQUM3QixPQUFPLEVBQWtCLElBQUk7WUFDN0IsTUFBTSxFQUFtQixJQUFJO1lBQzdCLGVBQWUsRUFBVSxJQUFJO1lBQzdCLGFBQWEsRUFBWSxLQUFLO1lBQzlCLE1BQU0sRUFBbUIsRUFBRSxDQUFDLFVBQVUsQ0FBQyxRQUFRO1lBQy9DLE1BQU0sRUFBbUIsQ0FBQyxDQUFDLFNBQVM7WUFDcEMsR0FBRyxFQUFzQixDQUFDLGNBQWMsQ0FBQztZQUN6QyxPQUFPLEVBQWtCLFNBQVM7WUFDbEMsS0FBSyxFQUFvQixFQUFFLFFBQVEsRUFBRSxDQUFDLG1DQUFtQyxDQUFDLEVBQUU7WUFDNUUsdUJBQXVCLEVBQUUsSUFBSTtZQUM3QixZQUFZLEVBQWEsSUFBSTtTQUNoQyxDQUFDO0lBQ04sQ0FBQztJQUVELE1BQU0sQ0FBQyxhQUFhLENBQUUsV0FBVztRQUM3QiwrQkFBK0I7UUFDL0IsTUFBTSxFQUFFLEdBQU8sT0FBTyxDQUFDLFlB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QyxDQUFDLENBQUM7UUFFSCxPQUFPLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQsb0JBQW9CO1FBQ2hCLE9BQU87WUFDSCxLQUFLLEVBQUUsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUM7WUFDNUQsS0FBSyxFQUFFLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsa0JBQXNCLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxRQUFRLENBQUM7U0FDdEcsQ0FBQztJQUNOLENBQUM7SUFFRCxJQUFJLGFBQWE7UUFDYixPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQscUJBQXFCO1FBQ2pCLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7Q0FDSjtBQWpHRCw2Q0FpR0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHppcE9iamVjdCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgT1MgZnJvbSAnb3MtZmFtaWx5JztcbmltcG9ydCBBUElCYXNlZFRlc3RGaWxlQ29tcGlsZXJCYXNlIGZyb20gJy4uLy4uL2FwaS1iYXNlZCc7XG5pbXBvcnQgRVNOZXh0VGVzdEZpbGVDb21waWxlciBmcm9tICcuLi9lcy1uZXh0L2NvbXBpbGVyJztcblxuXG5jb25zdCBSRU5BTUVEX0RFUEVOREVOQ0lFU19NQVAgPSBuZXcgTWFwKFtbJ3Rlc3RjYWZlJywgQVBJQmFzZWRUZXN0RmlsZUNvbXBpbGVyQmFzZS5FWFBPUlRBQkxFX0xJQl9QQVRIXV0pO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlciBleHRlbmRzIEFQSUJhc2VkVGVzdEZpbGVDb21waWxlckJhc2Uge1xuICAgIHN0YXRpYyBfZ2V0VHlwZXNjcmlwdE9wdGlvbnMgKCkge1xuICAgICAgICAvLyBOT1RFOiBsYXp5IGxvYWQgdGhlIGNvbXBpbGVyXG4gICAgICAgIGNvbnN0IHRzID0gcmVxdWlyZSgndHlwZXNjcmlwdCcpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBleHBlcmltZW50YWxEZWNvcmF0b3JzOiAgdHJ1ZSxcbiAgICAgICAgICAgIGVtaXREZWNvcmF0b3JNZXRhZGF0YTogICB0cnVlLFxuICAgICAgICAgICAgYWxsb3dKczogICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBwcmV0dHk6ICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIGlubGluZVNvdXJjZU1hcDogICAgICAgICB0cnVlLFxuICAgICAgICAgICAgbm9JbXBsaWNpdEFueTogICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgbW9kdWxlOiAgICAgICAgICAgICAgICAgIHRzLk1vZHVsZUtpbmQuQ29tbW9uSlMsXG4gICAgICAgICAgICB0YXJnZXQ6ICAgICAgICAgICAgICAgICAgMiAvKiBFUzYgKi8sXG4gICAgICAgICAgICBsaWI6ICAgICAgICAgICAgICAgICAgICAgWydsaWIuZXM2LmQudHMnXSxcbiAgICAgICAgICAgIGJhc2VVcmw6ICAgICAgICAgICAgICAgICBfX2Rpcm5hbWUsXG4gICAgICAgICAgICBwYXRoczogICAgICAgICAgICAgICAgICAgeyB0ZXN0Y2FmZTogWycuLi8uLi8uLi8uLi8uLi90cy1kZWZzL2luZGV4LmQudHMnXSB9LFxuICAgICAgICAgICAgc3VwcHJlc3NPdXRwdXRQYXRoQ2hlY2s6IHRydWUsXG4gICAgICAgICAgICBza2lwTGliQ2hlY2s6ICAgICAgICAgICAgdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyBfcmVwb3J0RXJyb3JzIChkaWFnbm9zdGljcykge1xuICAgICAgICAvLyBOT1RFOiBsYXp5IGxvYWQgdGhlIGNvbXBpbGVyXG4gICAgICAgIGNvbnN0IHRzICAgICA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQnKTtcbiAgICAgICAgbGV0IGVyck1zZyA9ICdUeXBlU2NyaXB0IGNvbXBpbGF0aW9uIGZhaWxlZC5cXG4nO1xuXG4gICAgICAgIGRpYWdub3N0aWNzLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlICAgICAgICAgICAgICAgID0gZC5maWxlO1xuICAgICAgICAgICAgY29uc3QgeyBsaW5lLCBjaGFyYWN0ZXIgfSA9IGZpbGUuZ2V0TGluZUFuZENoYXJhY3Rlck9mUG9zaXRpb24oZC5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlICAgICAgICAgICAgID0gdHMuZmxhdHRlbkRpYWdub3N0aWNNZXNzYWdlVGV4dChkLm1lc3NhZ2VUZXh0LCAnXFxuJyk7XG5cbiAgICAgICAgICAgIGVyck1zZyArPSBgJHtmaWxlLmZpbGVOYW1lfSAoJHtsaW5lICsgMX0sICR7Y2hhcmFjdGVyICsgMX0pOiAke21lc3NhZ2V9XFxuYDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgfVxuXG4gICAgc3RhdGljIF9ub3JtYWxpemVGaWxlbmFtZSAoZmlsZW5hbWUpIHtcbiAgICAgICAgZmlsZW5hbWUgPSBwYXRoLnJlc29sdmUoZmlsZW5hbWUpO1xuXG4gICAgICAgIGlmIChPUy53aW4pXG4gICAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cblxuICAgIF9wcmVjb21waWxlQ29kZSAodGVzdEZpbGVzSW5mbykge1xuICAgICAgICAvLyBOT1RFOiBsYXp5IGxvYWQgdGhlIGNvbXBpbGVyXG4gICAgICAgIGNvbnN0IHRzID0gcmVxdWlyZSgndHlwZXNjcmlwdCcpO1xuXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lcyAgICAgICAgICAgICAgPSB0ZXN0RmlsZXNJbmZvLm1hcCgoeyBmaWxlbmFtZSB9KSA9PiBmaWxlbmFtZSk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGaWxlbmFtZXMgICAgPSBmaWxlbmFtZXMubWFwKGZpbGVuYW1lID0+IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9ub3JtYWxpemVGaWxlbmFtZShmaWxlbmFtZSkpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkRmlsZW5hbWVzTWFwID0gemlwT2JqZWN0KG5vcm1hbGl6ZWRGaWxlbmFtZXMsIGZpbGVuYW1lcyk7XG5cbiAgICAgICAgY29uc3QgdW5jYWNoZWRGaWxlcyA9IG5vcm1hbGl6ZWRGaWxlbmFtZXNcbiAgICAgICAgICAgIC5maWx0ZXIoZmlsZW5hbWUgPT4gIXRoaXMuY2FjaGVbZmlsZW5hbWVdKVxuICAgICAgICAgICAgLm1hcChmaWxlbmFtZSA9PiBub3JtYWxpemVkRmlsZW5hbWVzTWFwW2ZpbGVuYW1lXSk7XG5cbiAgICAgICAgY29uc3Qgb3B0cyAgICA9IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9nZXRUeXBlc2NyaXB0T3B0aW9ucygpO1xuICAgICAgICBjb25zdCBwcm9ncmFtID0gdHMuY3JlYXRlUHJvZ3JhbSh1bmNhY2hlZEZpbGVzLCBvcHRzKTtcblxuICAgICAgICBwcm9ncmFtLmdldFNvdXJjZUZpbGVzKCkuZm9yRWFjaChzb3VyY2VGaWxlID0+IHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUucmVuYW1lZERlcGVuZGVuY2llcyA9IFJFTkFNRURfREVQRU5ERU5DSUVTX01BUDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZGlhZ25vc3RpY3MgPSB0cy5nZXRQcmVFbWl0RGlhZ25vc3RpY3MocHJvZ3JhbSk7XG5cbiAgICAgICAgaWYgKGRpYWdub3N0aWNzLmxlbmd0aClcbiAgICAgICAgICAgIFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9yZXBvcnRFcnJvcnMoZGlhZ25vc3RpY3MpO1xuXG4gICAgICAgIC8vIE5PVEU6IFRoZSBmaXJzdCBhcmd1bWVudCBvZiBlbWl0KCkgaXMgYSBzb3VyY2UgZmlsZSB0byBiZSBjb21waWxlZC4gSWYgaXQncyB1bmRlZmluZWQsIGFsbCBmaWxlcyBpblxuICAgICAgICAvLyA8cHJvZ3JhbT4gd2lsbCBiZSBjb21waWxlZC4gPHByb2dyYW0+IGNvbnRhaW5zIGEgZmlsZSBzcGVjaWZpZWQgaW4gY3JlYXRlUHJvZ3JhbSgpIHBsdXMgYWxsIGl0cyBkZXBlbmRlbmNpZXMuXG4gICAgICAgIC8vIFRoaXMgbW9kZSBpcyBtdWNoIGZhc3RlciB0aGFuIGNvbXBpbGluZyBmaWxlcyBvbmUtYnktb25lLCBhbmQgaXQgaXMgdXNlZCBpbiB0aGUgdHNjIENMSSBjb21waWxlci5cbiAgICAgICAgcHJvZ3JhbS5lbWl0KHZvaWQgMCwgKG91dHB1dE5hbWUsIHJlc3VsdCwgd3JpdGVCT00sIG9uRXJyb3IsIHNvdXJjZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBhdGggPSBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlci5fbm9ybWFsaXplRmlsZW5hbWUoc291cmNlc1swXS5maWxlTmFtZSk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVbc291cmNlUGF0aF0gPSByZXN1bHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkRmlsZW5hbWVzLm1hcChmaWxlbmFtZSA9PiB0aGlzLmNhY2hlW2ZpbGVuYW1lXSk7XG4gICAgfVxuXG4gICAgX2dldFJlcXVpcmVDb21waWxlcnMgKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJy50cyc6IChjb2RlLCBmaWxlbmFtZSkgPT4gdGhpcy5fY29tcGlsZUNvZGUoY29kZSwgZmlsZW5hbWUpLFxuICAgICAgICAgICAgJy5qcyc6IChjb2RlLCBmaWxlbmFtZSkgPT4gRVNOZXh0VGVzdEZpbGVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb2RlLmNhbGwodGhpcywgY29kZSwgZmlsZW5hbWUpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0IGNhblByZWNvbXBpbGUgKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBnZXRTdXBwb3J0ZWRFeHRlbnNpb24gKCkge1xuICAgICAgICByZXR1cm4gJy50cyc7XG4gICAgfVxufVxuIl19