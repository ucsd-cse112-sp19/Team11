'use strict';

exports.__esModule = true;
exports.default = processTestFnError;

var _path = require('path');

var _getCallsite = require('./get-callsite');

var _runtime = require('./runtime');

var _errorList = require('./error-list');

var _errorList2 = _interopRequireDefault(_errorList);

var _testRun = require('./test-run');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const INTERNAL = 'internal/';

function isAssertionErrorCallsiteFrame(frame) {
    const filename = frame.getFileName();

    // NOTE: filter out the internals of node.js and assertion libraries
    return filename && filename.indexOf(_path.sep) > -1 && filename.indexOf(INTERNAL) !== 0 && filename.indexOf(`${_path.sep}node_modules${_path.sep}`) < 0;
}

function processTestFnError(err) {
    if (err && (err.isTestCafeError || err instanceof _errorList2.default)) return err;

    if (err && err instanceof _runtime.APIError) return new _testRun.UncaughtErrorInTestCode(err);

    if (err instanceof Error) {
        const isAssertionError = err.name === 'AssertionError' || err.constructor.name === 'AssertionError';

        // NOTE: assertion libraries can add their source files to the error stack frames.
        // We should skip them to create a correct callsite for the assertion error.
        const callsite = isAssertionError ? (0, _getCallsite.getCallsiteForError)(err, isAssertionErrorCallsiteFrame) : (0, _getCallsite.getCallsiteForError)(err);

        return isAssertionError ? new _testRun.ExternalAssertionLibraryError(err, callsite) : new _testRun.UncaughtErrorInTestCode(err, callsite);
    }

    return new _testRun.UncaughtNonErrorObjectInTestCode(err);
}
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lcnJvcnMvcHJvY2Vzcy10ZXN0LWZuLWVycm9yLmpzIl0sIm5hbWVzIjpbInByb2Nlc3NUZXN0Rm5FcnJvciIsIklOVEVSTkFMIiwiaXNBc3NlcnRpb25FcnJvckNhbGxzaXRlRnJhbWUiLCJmcmFtZSIsImZpbGVuYW1lIiwiZ2V0RmlsZU5hbWUiLCJpbmRleE9mIiwic2VwIiwiZXJyIiwiaXNUZXN0Q2FmZUVycm9yIiwiVGVzdENhZmVFcnJvckxpc3QiLCJBUElFcnJvciIsIlVuY2F1Z2h0RXJyb3JJblRlc3RDb2RlIiwiRXJyb3IiLCJpc0Fzc2VydGlvbkVycm9yIiwibmFtZSIsImNvbnN0cnVjdG9yIiwiY2FsbHNpdGUiLCJFeHRlcm5hbEFzc2VydGlvbkxpYnJhcnlFcnJvciIsIlVuY2F1Z2h0Tm9uRXJyb3JPYmplY3RJblRlc3RDb2RlIl0sIm1hcHBpbmdzIjoiOzs7a0JBeUJ3QkEsa0I7O0FBekJ4Qjs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUVBOzs7O0FBT0EsTUFBTUMsV0FBVyxXQUFqQjs7QUFFQSxTQUFTQyw2QkFBVCxDQUF3Q0MsS0FBeEMsRUFBK0M7QUFDM0MsVUFBTUMsV0FBV0QsTUFBTUUsV0FBTixFQUFqQjs7QUFFQTtBQUNBLFdBQU9ELFlBQ0FBLFNBQVNFLE9BQVQsQ0FBaUJDLFNBQWpCLElBQXdCLENBQUMsQ0FEekIsSUFFQUgsU0FBU0UsT0FBVCxDQUFpQkwsUUFBakIsTUFBK0IsQ0FGL0IsSUFHQUcsU0FBU0UsT0FBVCxDQUFrQixHQUFFQyxTQUFJLGVBQWNBLFNBQUksRUFBMUMsSUFBK0MsQ0FIdEQ7QUFJSDs7QUFHYyxTQUFTUCxrQkFBVCxDQUE2QlEsR0FBN0IsRUFBa0M7QUFDN0MsUUFBSUEsUUFBUUEsSUFBSUMsZUFBSixJQUF1QkQsZUFBZUUsbUJBQTlDLENBQUosRUFDSSxPQUFPRixHQUFQOztBQUVKLFFBQUlBLE9BQU9BLGVBQWVHLGlCQUExQixFQUNJLE9BQU8sSUFBSUMsZ0NBQUosQ0FBNEJKLEdBQTVCLENBQVA7O0FBRUosUUFBSUEsZUFBZUssS0FBbkIsRUFBMEI7QUFDdEIsY0FBTUMsbUJBQW1CTixJQUFJTyxJQUFKLEtBQWEsZ0JBQWIsSUFBaUNQLElBQUlRLFdBQUosQ0FBZ0JELElBQWhCLEtBQXlCLGdCQUFuRjs7QUFFQTtBQUNBO0FBQ0EsY0FBTUUsV0FBV0gsbUJBQW1CLHNDQUFvQk4sR0FBcEIsRUFBeUJOLDZCQUF6QixDQUFuQixHQUE2RSxzQ0FBb0JNLEdBQXBCLENBQTlGOztBQUVBLGVBQU9NLG1CQUNILElBQUlJLHNDQUFKLENBQWtDVixHQUFsQyxFQUF1Q1MsUUFBdkMsQ0FERyxHQUVILElBQUlMLGdDQUFKLENBQTRCSixHQUE1QixFQUFpQ1MsUUFBakMsQ0FGSjtBQUdIOztBQUVELFdBQU8sSUFBSUUseUNBQUosQ0FBcUNYLEdBQXJDLENBQVA7QUFDSCIsImZpbGUiOiJlcnJvcnMvcHJvY2Vzcy10ZXN0LWZuLWVycm9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2VwIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBnZXRDYWxsc2l0ZUZvckVycm9yIH0gZnJvbSAnLi9nZXQtY2FsbHNpdGUnO1xuaW1wb3J0IHsgQVBJRXJyb3IgfSBmcm9tICcuL3J1bnRpbWUnO1xuaW1wb3J0IFRlc3RDYWZlRXJyb3JMaXN0IGZyb20gJy4vZXJyb3ItbGlzdCc7XG5cbmltcG9ydCB7XG4gICAgVW5jYXVnaHRFcnJvckluVGVzdENvZGUsXG4gICAgVW5jYXVnaHROb25FcnJvck9iamVjdEluVGVzdENvZGUsXG4gICAgRXh0ZXJuYWxBc3NlcnRpb25MaWJyYXJ5RXJyb3Jcbn0gZnJvbSAnLi90ZXN0LXJ1bic7XG5cblxuY29uc3QgSU5URVJOQUwgPSAnaW50ZXJuYWwvJztcblxuZnVuY3Rpb24gaXNBc3NlcnRpb25FcnJvckNhbGxzaXRlRnJhbWUgKGZyYW1lKSB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBmcmFtZS5nZXRGaWxlTmFtZSgpO1xuXG4gICAgLy8gTk9URTogZmlsdGVyIG91dCB0aGUgaW50ZXJuYWxzIG9mIG5vZGUuanMgYW5kIGFzc2VydGlvbiBsaWJyYXJpZXNcbiAgICByZXR1cm4gZmlsZW5hbWUgJiZcbiAgICAgICAgICAgZmlsZW5hbWUuaW5kZXhPZihzZXApID4gLTEgJiZcbiAgICAgICAgICAgZmlsZW5hbWUuaW5kZXhPZihJTlRFUk5BTCkgIT09IDAgJiZcbiAgICAgICAgICAgZmlsZW5hbWUuaW5kZXhPZihgJHtzZXB9bm9kZV9tb2R1bGVzJHtzZXB9YCkgPCAwO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByb2Nlc3NUZXN0Rm5FcnJvciAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiAoZXJyLmlzVGVzdENhZmVFcnJvciB8fCBlcnIgaW5zdGFuY2VvZiBUZXN0Q2FmZUVycm9yTGlzdCkpXG4gICAgICAgIHJldHVybiBlcnI7XG5cbiAgICBpZiAoZXJyICYmIGVyciBpbnN0YW5jZW9mIEFQSUVycm9yKVxuICAgICAgICByZXR1cm4gbmV3IFVuY2F1Z2h0RXJyb3JJblRlc3RDb2RlKGVycik7XG5cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgY29uc3QgaXNBc3NlcnRpb25FcnJvciA9IGVyci5uYW1lID09PSAnQXNzZXJ0aW9uRXJyb3InIHx8IGVyci5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXNzZXJ0aW9uRXJyb3InO1xuXG4gICAgICAgIC8vIE5PVEU6IGFzc2VydGlvbiBsaWJyYXJpZXMgY2FuIGFkZCB0aGVpciBzb3VyY2UgZmlsZXMgdG8gdGhlIGVycm9yIHN0YWNrIGZyYW1lcy5cbiAgICAgICAgLy8gV2Ugc2hvdWxkIHNraXAgdGhlbSB0byBjcmVhdGUgYSBjb3JyZWN0IGNhbGxzaXRlIGZvciB0aGUgYXNzZXJ0aW9uIGVycm9yLlxuICAgICAgICBjb25zdCBjYWxsc2l0ZSA9IGlzQXNzZXJ0aW9uRXJyb3IgPyBnZXRDYWxsc2l0ZUZvckVycm9yKGVyciwgaXNBc3NlcnRpb25FcnJvckNhbGxzaXRlRnJhbWUpIDogZ2V0Q2FsbHNpdGVGb3JFcnJvcihlcnIpO1xuXG4gICAgICAgIHJldHVybiBpc0Fzc2VydGlvbkVycm9yID9cbiAgICAgICAgICAgIG5ldyBFeHRlcm5hbEFzc2VydGlvbkxpYnJhcnlFcnJvcihlcnIsIGNhbGxzaXRlKSA6XG4gICAgICAgICAgICBuZXcgVW5jYXVnaHRFcnJvckluVGVzdENvZGUoZXJyLCBjYWxsc2l0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBVbmNhdWdodE5vbkVycm9yT2JqZWN0SW5UZXN0Q29kZShlcnIpO1xufVxuIl19
