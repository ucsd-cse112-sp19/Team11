"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = require("os");
const data_file_1 = __importDefault(require("./data-file"));
const messages_1 = __importDefault(require("./messages"));
const get_message_index_1 = __importDefault(require("./get-message-index"));
const render_template_1 = __importDefault(require("../utils/render-template"));
const warning_message_1 = __importDefault(require("../notifications/warning-message"));
const log_1 = __importDefault(require("../cli/log"));
const debug_1 = __importDefault(require("debug"));
exports.NUMBER_RUNS_BETWEEN_SHOW_MESSAGE = 10;
const DEBUG_LOGGER = debug_1.default('testcafe:marketing');
// For testing purposes
exports._dataFile = new data_file_1.default();
async function showMessageWithLinkToTestCafeStudio() {
    const data = await exports._dataFile.load();
    // NOTE: Don't show messages in case of the IO errors
    if (!data)
        return;
    data.runCount++;
    const shouldDisplayMessage = data.runCount === 1 || data.runCount % exports.NUMBER_RUNS_BETWEEN_SHOW_MESSAGE === 0;
    if (shouldDisplayMessage) {
        const messageIndex = get_message_index_1.default(messages_1.default, data);
        const targetMsg = messages_1.default[messageIndex];
        if (!targetMsg) {
            const message = render_template_1.default(warning_message_1.default.cannotCalculateMarketingMessage, messageIndex);
            DEBUG_LOGGER(message);
        }
        log_1.default.write(os_1.EOL + targetMsg);
    }
    await exports._dataFile.save(data);
}
exports.showMessageWithLinkToTestCafeStudio = showMessageWithLinkToTestCafeStudio;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbWFya2V0aW5nL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsMkJBQXlCO0FBQ3pCLDREQUFtQztBQUNuQywwREFBa0M7QUFDbEMsNEVBQWtEO0FBQ2xELCtFQUFzRDtBQUN0RCx1RkFBZ0U7QUFDaEUscURBQTZCO0FBQzdCLGtEQUEwQjtBQUViLFFBQUEsZ0NBQWdDLEdBQUcsRUFBRSxDQUFDO0FBRW5ELE1BQU0sWUFBWSxHQUFHLGVBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBRWpELHVCQUF1QjtBQUNWLFFBQUEsU0FBUyxHQUFHLElBQUksbUJBQVEsRUFBRSxDQUFDO0FBRWpDLEtBQUssVUFBVSxtQ0FBbUM7SUFDckQsTUFBTSxJQUFJLEdBQUcsTUFBTSxpQkFBUyxDQUFDLElBQUksRUFBRSxDQUFDO0lBRXBDLHFEQUFxRDtJQUNyRCxJQUFJLENBQUMsSUFBSTtRQUNMLE9BQU87SUFFWCxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFFaEIsTUFBTSxvQkFBb0IsR0FBRyxJQUFJLENBQUMsUUFBUSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxHQUFHLHdDQUFnQyxLQUFLLENBQUMsQ0FBQztJQUUzRyxJQUFJLG9CQUFvQixFQUFFO1FBQ3RCLE1BQU0sWUFBWSxHQUFHLDJCQUFlLENBQUMsa0JBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNyRCxNQUFNLFNBQVMsR0FBTSxrQkFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRTVDLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDWixNQUFNLE9BQU8sR0FBRyx5QkFBYyxDQUFDLHlCQUFnQixDQUFDLCtCQUErQixFQUFFLFlBQVksQ0FBQyxDQUFDO1lBRS9GLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN6QjtRQUVELGFBQUcsQ0FBQyxLQUFLLENBQUMsUUFBRyxHQUFHLFNBQVMsQ0FBQyxDQUFDO0tBQzlCO0lBRUQsTUFBTSxpQkFBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMvQixDQUFDO0FBekJELGtGQXlCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVPTCB9IGZyb20gJ29zJztcbmltcG9ydCBEYXRhRmlsZSBmcm9tICcuL2RhdGEtZmlsZSc7XG5pbXBvcnQgTUVTU0FHRVMgZnJvbSAnLi9tZXNzYWdlcyc7XG5pbXBvcnQgZ2V0TWVzc2FnZUluZGV4IGZyb20gJy4vZ2V0LW1lc3NhZ2UtaW5kZXgnO1xuaW1wb3J0IHJlbmRlclRlbXBsYXRlIGZyb20gJy4uL3V0aWxzL3JlbmRlci10ZW1wbGF0ZSc7XG5pbXBvcnQgV0FSTklOR19NRVNTQUdFUyBmcm9tICcuLi9ub3RpZmljYXRpb25zL3dhcm5pbmctbWVzc2FnZSc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2NsaS9sb2cnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcblxuZXhwb3J0IGNvbnN0IE5VTUJFUl9SVU5TX0JFVFdFRU5fU0hPV19NRVNTQUdFID0gMTA7XG5cbmNvbnN0IERFQlVHX0xPR0dFUiA9IGRlYnVnKCd0ZXN0Y2FmZTptYXJrZXRpbmcnKTtcblxuLy8gRm9yIHRlc3RpbmcgcHVycG9zZXNcbmV4cG9ydCBjb25zdCBfZGF0YUZpbGUgPSBuZXcgRGF0YUZpbGUoKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNob3dNZXNzYWdlV2l0aExpbmtUb1Rlc3RDYWZlU3R1ZGlvICgpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgX2RhdGFGaWxlLmxvYWQoKTtcblxuICAgIC8vIE5PVEU6IERvbid0IHNob3cgbWVzc2FnZXMgaW4gY2FzZSBvZiB0aGUgSU8gZXJyb3JzXG4gICAgaWYgKCFkYXRhKVxuICAgICAgICByZXR1cm47XG5cbiAgICBkYXRhLnJ1bkNvdW50Kys7XG5cbiAgICBjb25zdCBzaG91bGREaXNwbGF5TWVzc2FnZSA9IGRhdGEucnVuQ291bnQgPT09IDEgfHwgZGF0YS5ydW5Db3VudCAlIE5VTUJFUl9SVU5TX0JFVFdFRU5fU0hPV19NRVNTQUdFID09PSAwO1xuXG4gICAgaWYgKHNob3VsZERpc3BsYXlNZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VJbmRleCA9IGdldE1lc3NhZ2VJbmRleChNRVNTQUdFUywgZGF0YSk7XG4gICAgICAgIGNvbnN0IHRhcmdldE1zZyAgICA9IE1FU1NBR0VTW21lc3NhZ2VJbmRleF07XG5cbiAgICAgICAgaWYgKCF0YXJnZXRNc2cpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZW5kZXJUZW1wbGF0ZShXQVJOSU5HX01FU1NBR0VTLmNhbm5vdENhbGN1bGF0ZU1hcmtldGluZ01lc3NhZ2UsIG1lc3NhZ2VJbmRleCk7XG5cbiAgICAgICAgICAgIERFQlVHX0xPR0dFUihtZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZy53cml0ZShFT0wgKyB0YXJnZXRNc2cpO1xuICAgIH1cblxuICAgIGF3YWl0IF9kYXRhRmlsZS5zYXZlKGRhdGEpO1xufVxuIl19