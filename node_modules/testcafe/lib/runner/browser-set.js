'use strict';

exports.__esModule = true;

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _events = require('events');

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _timeLimitPromise = require('time-limit-promise');

var _timeLimitPromise2 = _interopRequireDefault(_timeLimitPromise);

var _promisifyEvent = require('promisify-event');

var _promisifyEvent2 = _interopRequireDefault(_promisifyEvent);

var _lodash = require('lodash');

var _mapReverse = require('map-reverse');

var _mapReverse2 = _interopRequireDefault(_mapReverse);

var _runtime = require('../errors/runtime');

var _types = require('../errors/types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const LOCAL_BROWSERS_READY_TIMEOUT = 2 * 60 * 1000;
const REMOTE_BROWSERS_READY_TIMEOUT = 6 * 60 * 1000;

class BrowserSet extends _events.EventEmitter {
    constructor(browserConnectionGroups) {
        super();

        this.RELEASE_TIMEOUT = 10000;

        this.pendingReleases = [];

        this.browserConnectionGroups = browserConnectionGroups;
        this.browserConnections = (0, _lodash.flatten)(browserConnectionGroups);

        this.connectionsReadyTimeout = null;

        this.browserErrorHandler = error => this.emit('error', error);

        this.browserConnections.forEach(bc => bc.on('error', this.browserErrorHandler));

        // NOTE: We're setting an empty error handler, because Node kills the process on an 'error' event
        // if there is no handler. See: https://nodejs.org/api/events.html#events_class_events_eventemitter
        this.on('error', _lodash.noop);
    }

    static _waitIdle(bc) {
        return (0, _asyncToGenerator3.default)(function* () {
            if (bc.idle || !bc.ready) return;

            yield (0, _promisifyEvent2.default)(bc, 'idle');
        })();
    }

    static _closeConnection(bc) {
        return (0, _asyncToGenerator3.default)(function* () {
            if (bc.closed || !bc.ready) return;

            bc.close();

            yield (0, _promisifyEvent2.default)(bc, 'closed');
        })();
    }

    _getReadyTimeout() {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            const isLocalBrowser = function isLocalBrowser(connection) {
                return connection.provider.isLocalBrowser(connection.id, connection.browserInfo.browserName);
            };
            const remoteBrowsersExist = (yield _pinkie2.default.all(_this.browserConnections.map(isLocalBrowser))).indexOf(false) > -1;

            return remoteBrowsersExist ? REMOTE_BROWSERS_READY_TIMEOUT : LOCAL_BROWSERS_READY_TIMEOUT;
        })();
    }

    _createPendingConnectionPromise(readyPromise, timeout, timeoutError) {
        const timeoutPromise = new _pinkie2.default((_, reject) => {
            this.connectionsReadyTimeout = setTimeout(() => reject(timeoutError), timeout);
        });

        return _pinkie2.default.race([readyPromise, timeoutPromise]).then(value => {
            this.connectionsReadyTimeout.unref();
            return value;
        }, error => {
            this.connectionsReadyTimeout.unref();
            throw error;
        });
    }

    _waitConnectionsOpened() {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            const connectionsReadyPromise = _pinkie2.default.all(_this2.browserConnections.filter(function (bc) {
                return !bc.opened;
            }).map(function (bc) {
                return (0, _promisifyEvent2.default)(bc, 'opened');
            }));

            const timeoutError = new _runtime.GeneralError(_types.RUNTIME_ERRORS.cannotEstablishBrowserConnection);
            const readyTimeout = yield _this2._getReadyTimeout();

            yield _this2._createPendingConnectionPromise(connectionsReadyPromise, readyTimeout, timeoutError);
        })();
    }

    _checkForDisconnections() {
        const disconnectedUserAgents = this.browserConnections.filter(bc => bc.closed).map(bc => bc.userAgent);

        if (disconnectedUserAgents.length) throw new _runtime.GeneralError(_types.RUNTIME_ERRORS.cannotRunAgainstDisconnectedBrowsers, disconnectedUserAgents.join(', '));
    }

    //API
    static from(browserConnections) {
        const browserSet = new BrowserSet(browserConnections);

        const prepareConnection = _pinkie2.default.resolve().then(() => {
            browserSet._checkForDisconnections();
            return browserSet._waitConnectionsOpened();
        }).then(() => browserSet);

        return _pinkie2.default.race([prepareConnection, (0, _promisifyEvent2.default)(browserSet, 'error')]).catch((() => {
            var _ref = (0, _asyncToGenerator3.default)(function* (error) {
                yield browserSet.dispose();

                throw error;
            });

            return function (_x) {
                return _ref.apply(this, arguments);
            };
        })());
    }

    releaseConnection(bc) {
        if (this.browserConnections.indexOf(bc) < 0) return _pinkie2.default.resolve();

        (0, _lodash.pull)(this.browserConnections, bc);

        bc.removeListener('error', this.browserErrorHandler);

        const appropriateStateSwitch = !bc.permanent ? BrowserSet._closeConnection(bc) : BrowserSet._waitIdle(bc);

        const release = (0, _timeLimitPromise2.default)(appropriateStateSwitch, this.RELEASE_TIMEOUT).then(() => (0, _lodash.pull)(this.pendingReleases, release));

        this.pendingReleases.push(release);

        return release;
    }

    dispose() {
        var _this3 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            // NOTE: When browserConnection is cancelled, it is removed from
            // the this.connections array, which leads to shifting indexes
            // towards the beginning. So, we must copy the array in order to iterate it,
            // or we can perform iteration from the end to the beginning.
            if (_this3.connectionsReadyTimeout) _this3.connectionsReadyTimeout.unref();

            (0, _mapReverse2.default)(_this3.browserConnections, function (bc) {
                return _this3.releaseConnection(bc);
            });

            yield _pinkie2.default.all(_this3.pendingReleases);
        })();
    }
}
exports.default = BrowserSet;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydW5uZXIvYnJvd3Nlci1zZXQuanMiXSwibmFtZXMiOlsiTE9DQUxfQlJPV1NFUlNfUkVBRFlfVElNRU9VVCIsIlJFTU9URV9CUk9XU0VSU19SRUFEWV9USU1FT1VUIiwiQnJvd3NlclNldCIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwiYnJvd3NlckNvbm5lY3Rpb25Hcm91cHMiLCJSRUxFQVNFX1RJTUVPVVQiLCJwZW5kaW5nUmVsZWFzZXMiLCJicm93c2VyQ29ubmVjdGlvbnMiLCJjb25uZWN0aW9uc1JlYWR5VGltZW91dCIsImJyb3dzZXJFcnJvckhhbmRsZXIiLCJlcnJvciIsImVtaXQiLCJmb3JFYWNoIiwiYmMiLCJvbiIsIm5vb3AiLCJfd2FpdElkbGUiLCJpZGxlIiwicmVhZHkiLCJfY2xvc2VDb25uZWN0aW9uIiwiY2xvc2VkIiwiY2xvc2UiLCJfZ2V0UmVhZHlUaW1lb3V0IiwiaXNMb2NhbEJyb3dzZXIiLCJjb25uZWN0aW9uIiwicHJvdmlkZXIiLCJpZCIsImJyb3dzZXJJbmZvIiwiYnJvd3Nlck5hbWUiLCJyZW1vdGVCcm93c2Vyc0V4aXN0IiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImluZGV4T2YiLCJfY3JlYXRlUGVuZGluZ0Nvbm5lY3Rpb25Qcm9taXNlIiwicmVhZHlQcm9taXNlIiwidGltZW91dCIsInRpbWVvdXRFcnJvciIsInRpbWVvdXRQcm9taXNlIiwiXyIsInJlamVjdCIsInNldFRpbWVvdXQiLCJyYWNlIiwidGhlbiIsInZhbHVlIiwidW5yZWYiLCJfd2FpdENvbm5lY3Rpb25zT3BlbmVkIiwiY29ubmVjdGlvbnNSZWFkeVByb21pc2UiLCJmaWx0ZXIiLCJvcGVuZWQiLCJHZW5lcmFsRXJyb3IiLCJSVU5USU1FX0VSUk9SUyIsImNhbm5vdEVzdGFibGlzaEJyb3dzZXJDb25uZWN0aW9uIiwicmVhZHlUaW1lb3V0IiwiX2NoZWNrRm9yRGlzY29ubmVjdGlvbnMiLCJkaXNjb25uZWN0ZWRVc2VyQWdlbnRzIiwidXNlckFnZW50IiwibGVuZ3RoIiwiY2Fubm90UnVuQWdhaW5zdERpc2Nvbm5lY3RlZEJyb3dzZXJzIiwiam9pbiIsImZyb20iLCJicm93c2VyU2V0IiwicHJlcGFyZUNvbm5lY3Rpb24iLCJyZXNvbHZlIiwiY2F0Y2giLCJkaXNwb3NlIiwicmVsZWFzZUNvbm5lY3Rpb24iLCJyZW1vdmVMaXN0ZW5lciIsImFwcHJvcHJpYXRlU3RhdGVTd2l0Y2giLCJwZXJtYW5lbnQiLCJyZWxlYXNlIiwicHVzaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBRUEsTUFBTUEsK0JBQWdDLElBQUksRUFBSixHQUFTLElBQS9DO0FBQ0EsTUFBTUMsZ0NBQWdDLElBQUksRUFBSixHQUFTLElBQS9DOztBQUVlLE1BQU1DLFVBQU4sU0FBeUJDLG9CQUF6QixDQUFzQztBQUNqREMsZ0JBQWFDLHVCQUFiLEVBQXNDO0FBQ2xDOztBQUVBLGFBQUtDLGVBQUwsR0FBdUIsS0FBdkI7O0FBRUEsYUFBS0MsZUFBTCxHQUF1QixFQUF2Qjs7QUFFQSxhQUFLRix1QkFBTCxHQUErQkEsdUJBQS9CO0FBQ0EsYUFBS0csa0JBQUwsR0FBK0IscUJBQVFILHVCQUFSLENBQS9COztBQUVBLGFBQUtJLHVCQUFMLEdBQStCLElBQS9COztBQUVBLGFBQUtDLG1CQUFMLEdBQTJCQyxTQUFTLEtBQUtDLElBQUwsQ0FBVSxPQUFWLEVBQW1CRCxLQUFuQixDQUFwQzs7QUFFQSxhQUFLSCxrQkFBTCxDQUF3QkssT0FBeEIsQ0FBZ0NDLE1BQU1BLEdBQUdDLEVBQUgsQ0FBTSxPQUFOLEVBQWUsS0FBS0wsbUJBQXBCLENBQXRDOztBQUVBO0FBQ0E7QUFDQSxhQUFLSyxFQUFMLENBQVEsT0FBUixFQUFpQkMsWUFBakI7QUFDSDs7QUFFRCxXQUFhQyxTQUFiLENBQXdCSCxFQUF4QixFQUE0QjtBQUFBO0FBQ3hCLGdCQUFJQSxHQUFHSSxJQUFILElBQVcsQ0FBQ0osR0FBR0ssS0FBbkIsRUFDSTs7QUFFSixrQkFBTSw4QkFBZUwsRUFBZixFQUFtQixNQUFuQixDQUFOO0FBSndCO0FBSzNCOztBQUVELFdBQWFNLGdCQUFiLENBQStCTixFQUEvQixFQUFtQztBQUFBO0FBQy9CLGdCQUFJQSxHQUFHTyxNQUFILElBQWEsQ0FBQ1AsR0FBR0ssS0FBckIsRUFDSTs7QUFFSkwsZUFBR1EsS0FBSDs7QUFFQSxrQkFBTSw4QkFBZVIsRUFBZixFQUFtQixRQUFuQixDQUFOO0FBTitCO0FBT2xDOztBQUVLUyxvQkFBTixHQUEwQjtBQUFBOztBQUFBO0FBQ3RCLGtCQUFNQyxpQkFBc0IsU0FBdEJBLGNBQXNCO0FBQUEsdUJBQWNDLFdBQVdDLFFBQVgsQ0FBb0JGLGNBQXBCLENBQW1DQyxXQUFXRSxFQUE5QyxFQUFrREYsV0FBV0csV0FBWCxDQUF1QkMsV0FBekUsQ0FBZDtBQUFBLGFBQTVCO0FBQ0Esa0JBQU1DLHNCQUFzQixDQUFDLE1BQU1DLGlCQUFRQyxHQUFSLENBQVksTUFBS3hCLGtCQUFMLENBQXdCeUIsR0FBeEIsQ0FBNEJULGNBQTVCLENBQVosQ0FBUCxFQUFpRVUsT0FBakUsQ0FBeUUsS0FBekUsSUFBa0YsQ0FBQyxDQUEvRzs7QUFFQSxtQkFBT0osc0JBQXNCN0IsNkJBQXRCLEdBQXNERCw0QkFBN0Q7QUFKc0I7QUFLekI7O0FBRURtQyxvQ0FBaUNDLFlBQWpDLEVBQStDQyxPQUEvQyxFQUF3REMsWUFBeEQsRUFBc0U7QUFDbEUsY0FBTUMsaUJBQWlCLElBQUlSLGdCQUFKLENBQVksQ0FBQ1MsQ0FBRCxFQUFJQyxNQUFKLEtBQWU7QUFDOUMsaUJBQUtoQyx1QkFBTCxHQUErQmlDLFdBQVcsTUFBTUQsT0FBT0gsWUFBUCxDQUFqQixFQUF1Q0QsT0FBdkMsQ0FBL0I7QUFDSCxTQUZzQixDQUF2Qjs7QUFJQSxlQUFPTixpQkFDRlksSUFERSxDQUNHLENBQUNQLFlBQUQsRUFBZUcsY0FBZixDQURILEVBRUZLLElBRkUsQ0FHQ0MsU0FBUztBQUNMLGlCQUFLcEMsdUJBQUwsQ0FBNkJxQyxLQUE3QjtBQUNBLG1CQUFPRCxLQUFQO0FBQ0gsU0FORixFQU9DbEMsU0FBUztBQUNMLGlCQUFLRix1QkFBTCxDQUE2QnFDLEtBQTdCO0FBQ0Esa0JBQU1uQyxLQUFOO0FBQ0gsU0FWRixDQUFQO0FBWUg7O0FBRUtvQywwQkFBTixHQUFnQztBQUFBOztBQUFBO0FBQzVCLGtCQUFNQywwQkFBMEJqQixpQkFBUUMsR0FBUixDQUM1QixPQUFLeEIsa0JBQUwsQ0FDS3lDLE1BREwsQ0FDWTtBQUFBLHVCQUFNLENBQUNuQyxHQUFHb0MsTUFBVjtBQUFBLGFBRFosRUFFS2pCLEdBRkwsQ0FFUztBQUFBLHVCQUFNLDhCQUFlbkIsRUFBZixFQUFtQixRQUFuQixDQUFOO0FBQUEsYUFGVCxDQUQ0QixDQUFoQzs7QUFNQSxrQkFBTXdCLGVBQWUsSUFBSWEscUJBQUosQ0FBaUJDLHNCQUFlQyxnQ0FBaEMsQ0FBckI7QUFDQSxrQkFBTUMsZUFBZSxNQUFNLE9BQUsvQixnQkFBTCxFQUEzQjs7QUFFQSxrQkFBTSxPQUFLWSwrQkFBTCxDQUFxQ2EsdUJBQXJDLEVBQThETSxZQUE5RCxFQUE0RWhCLFlBQTVFLENBQU47QUFWNEI7QUFXL0I7O0FBRURpQiw4QkFBMkI7QUFDdkIsY0FBTUMseUJBQXlCLEtBQUtoRCxrQkFBTCxDQUMxQnlDLE1BRDBCLENBQ25CbkMsTUFBTUEsR0FBR08sTUFEVSxFQUUxQlksR0FGMEIsQ0FFdEJuQixNQUFNQSxHQUFHMkMsU0FGYSxDQUEvQjs7QUFJQSxZQUFJRCx1QkFBdUJFLE1BQTNCLEVBQ0ksTUFBTSxJQUFJUCxxQkFBSixDQUFpQkMsc0JBQWVPLG9DQUFoQyxFQUFzRUgsdUJBQXVCSSxJQUF2QixDQUE0QixJQUE1QixDQUF0RSxDQUFOO0FBQ1A7O0FBR0Q7QUFDQSxXQUFPQyxJQUFQLENBQWFyRCxrQkFBYixFQUFpQztBQUM3QixjQUFNc0QsYUFBYSxJQUFJNUQsVUFBSixDQUFlTSxrQkFBZixDQUFuQjs7QUFFQSxjQUFNdUQsb0JBQW9CaEMsaUJBQVFpQyxPQUFSLEdBQ3JCcEIsSUFEcUIsQ0FDaEIsTUFBTTtBQUNSa0IsdUJBQVdQLHVCQUFYO0FBQ0EsbUJBQU9PLFdBQVdmLHNCQUFYLEVBQVA7QUFDSCxTQUpxQixFQUtyQkgsSUFMcUIsQ0FLaEIsTUFBTWtCLFVBTFUsQ0FBMUI7O0FBT0EsZUFBTy9CLGlCQUNGWSxJQURFLENBQ0csQ0FDRm9CLGlCQURFLEVBRUYsOEJBQWVELFVBQWYsRUFBMkIsT0FBM0IsQ0FGRSxDQURILEVBS0ZHLEtBTEU7QUFBQSx1REFLSSxXQUFNdEQsS0FBTixFQUFlO0FBQ2xCLHNCQUFNbUQsV0FBV0ksT0FBWCxFQUFOOztBQUVBLHNCQUFNdkQsS0FBTjtBQUNILGFBVEU7O0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFBUDtBQVVIOztBQUVEd0Qsc0JBQW1CckQsRUFBbkIsRUFBdUI7QUFDbkIsWUFBSSxLQUFLTixrQkFBTCxDQUF3QjBCLE9BQXhCLENBQWdDcEIsRUFBaEMsSUFBc0MsQ0FBMUMsRUFDSSxPQUFPaUIsaUJBQVFpQyxPQUFSLEVBQVA7O0FBRUosMEJBQU8sS0FBS3hELGtCQUFaLEVBQWdDTSxFQUFoQzs7QUFFQUEsV0FBR3NELGNBQUgsQ0FBa0IsT0FBbEIsRUFBMkIsS0FBSzFELG1CQUFoQzs7QUFFQSxjQUFNMkQseUJBQXlCLENBQUN2RCxHQUFHd0QsU0FBSixHQUMzQnBFLFdBQVdrQixnQkFBWCxDQUE0Qk4sRUFBNUIsQ0FEMkIsR0FFM0JaLFdBQVdlLFNBQVgsQ0FBcUJILEVBQXJCLENBRko7O0FBSUEsY0FBTXlELFVBQVUsZ0NBQXNCRixzQkFBdEIsRUFBOEMsS0FBSy9ELGVBQW5ELEVBQW9Fc0MsSUFBcEUsQ0FBeUUsTUFBTSxrQkFBTyxLQUFLckMsZUFBWixFQUE2QmdFLE9BQTdCLENBQS9FLENBQWhCOztBQUVBLGFBQUtoRSxlQUFMLENBQXFCaUUsSUFBckIsQ0FBMEJELE9BQTFCOztBQUVBLGVBQU9BLE9BQVA7QUFDSDs7QUFFS0wsV0FBTixHQUFpQjtBQUFBOztBQUFBO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBSSxPQUFLekQsdUJBQVQsRUFDSSxPQUFLQSx1QkFBTCxDQUE2QnFDLEtBQTdCOztBQUVKLHNDQUFXLE9BQUt0QyxrQkFBaEIsRUFBb0M7QUFBQSx1QkFBTSxPQUFLMkQsaUJBQUwsQ0FBdUJyRCxFQUF2QixDQUFOO0FBQUEsYUFBcEM7O0FBRUEsa0JBQU1pQixpQkFBUUMsR0FBUixDQUFZLE9BQUt6QixlQUFqQixDQUFOO0FBVmE7QUFXaEI7QUE1SWdEO2tCQUFoQ0wsVSIsImZpbGUiOiJydW5uZXIvYnJvd3Nlci1zZXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAncGlua2llJztcbmltcG9ydCBnZXRUaW1lTGltaXRlZFByb21pc2UgZnJvbSAndGltZS1saW1pdC1wcm9taXNlJztcbmltcG9ydCBwcm9taXNpZnlFdmVudCBmcm9tICdwcm9taXNpZnktZXZlbnQnO1xuaW1wb3J0IHsgbm9vcCwgcHVsbCBhcyByZW1vdmUsIGZsYXR0ZW4gfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IG1hcFJldmVyc2UgZnJvbSAnbWFwLXJldmVyc2UnO1xuaW1wb3J0IHsgR2VuZXJhbEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3J1bnRpbWUnO1xuaW1wb3J0IHsgUlVOVElNRV9FUlJPUlMgfSBmcm9tICcuLi9lcnJvcnMvdHlwZXMnO1xuXG5jb25zdCBMT0NBTF9CUk9XU0VSU19SRUFEWV9USU1FT1VUICA9IDIgKiA2MCAqIDEwMDA7XG5jb25zdCBSRU1PVEVfQlJPV1NFUlNfUkVBRFlfVElNRU9VVCA9IDYgKiA2MCAqIDEwMDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJyb3dzZXJTZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yIChicm93c2VyQ29ubmVjdGlvbkdyb3Vwcykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuUkVMRUFTRV9USU1FT1VUID0gMTAwMDA7XG5cbiAgICAgICAgdGhpcy5wZW5kaW5nUmVsZWFzZXMgPSBbXTtcblxuICAgICAgICB0aGlzLmJyb3dzZXJDb25uZWN0aW9uR3JvdXBzID0gYnJvd3NlckNvbm5lY3Rpb25Hcm91cHM7XG4gICAgICAgIHRoaXMuYnJvd3NlckNvbm5lY3Rpb25zICAgICAgPSBmbGF0dGVuKGJyb3dzZXJDb25uZWN0aW9uR3JvdXBzKTtcblxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zUmVhZHlUaW1lb3V0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLmJyb3dzZXJFcnJvckhhbmRsZXIgPSBlcnJvciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXG4gICAgICAgIHRoaXMuYnJvd3NlckNvbm5lY3Rpb25zLmZvckVhY2goYmMgPT4gYmMub24oJ2Vycm9yJywgdGhpcy5icm93c2VyRXJyb3JIYW5kbGVyKSk7XG5cbiAgICAgICAgLy8gTk9URTogV2UncmUgc2V0dGluZyBhbiBlbXB0eSBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIE5vZGUga2lsbHMgdGhlIHByb2Nlc3Mgb24gYW4gJ2Vycm9yJyBldmVudFxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBoYW5kbGVyLiBTZWU6IGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2NsYXNzX2V2ZW50c19ldmVudGVtaXR0ZXJcbiAgICAgICAgdGhpcy5vbignZXJyb3InLCBub29wKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgX3dhaXRJZGxlIChiYykge1xuICAgICAgICBpZiAoYmMuaWRsZSB8fCAhYmMucmVhZHkpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgYXdhaXQgcHJvbWlzaWZ5RXZlbnQoYmMsICdpZGxlJyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIF9jbG9zZUNvbm5lY3Rpb24gKGJjKSB7XG4gICAgICAgIGlmIChiYy5jbG9zZWQgfHwgIWJjLnJlYWR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGJjLmNsb3NlKCk7XG5cbiAgICAgICAgYXdhaXQgcHJvbWlzaWZ5RXZlbnQoYmMsICdjbG9zZWQnKTtcbiAgICB9XG5cbiAgICBhc3luYyBfZ2V0UmVhZHlUaW1lb3V0ICgpIHtcbiAgICAgICAgY29uc3QgaXNMb2NhbEJyb3dzZXIgICAgICA9IGNvbm5lY3Rpb24gPT4gY29ubmVjdGlvbi5wcm92aWRlci5pc0xvY2FsQnJvd3Nlcihjb25uZWN0aW9uLmlkLCBjb25uZWN0aW9uLmJyb3dzZXJJbmZvLmJyb3dzZXJOYW1lKTtcbiAgICAgICAgY29uc3QgcmVtb3RlQnJvd3NlcnNFeGlzdCA9IChhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmJyb3dzZXJDb25uZWN0aW9ucy5tYXAoaXNMb2NhbEJyb3dzZXIpKSkuaW5kZXhPZihmYWxzZSkgPiAtMTtcblxuICAgICAgICByZXR1cm4gcmVtb3RlQnJvd3NlcnNFeGlzdCA/IFJFTU9URV9CUk9XU0VSU19SRUFEWV9USU1FT1VUIDogTE9DQUxfQlJPV1NFUlNfUkVBRFlfVElNRU9VVDtcbiAgICB9XG5cbiAgICBfY3JlYXRlUGVuZGluZ0Nvbm5lY3Rpb25Qcm9taXNlIChyZWFkeVByb21pc2UsIHRpbWVvdXQsIHRpbWVvdXRFcnJvcikge1xuICAgICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbnNSZWFkeVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHJlamVjdCh0aW1lb3V0RXJyb3IpLCB0aW1lb3V0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VcbiAgICAgICAgICAgIC5yYWNlKFtyZWFkeVByb21pc2UsIHRpbWVvdXRQcm9taXNlXSlcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAgIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uc1JlYWR5VGltZW91dC51bnJlZigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbnNSZWFkeVRpbWVvdXQudW5yZWYoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICBhc3luYyBfd2FpdENvbm5lY3Rpb25zT3BlbmVkICgpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbnNSZWFkeVByb21pc2UgPSBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIHRoaXMuYnJvd3NlckNvbm5lY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcihiYyA9PiAhYmMub3BlbmVkKVxuICAgICAgICAgICAgICAgIC5tYXAoYmMgPT4gcHJvbWlzaWZ5RXZlbnQoYmMsICdvcGVuZWQnKSlcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCB0aW1lb3V0RXJyb3IgPSBuZXcgR2VuZXJhbEVycm9yKFJVTlRJTUVfRVJST1JTLmNhbm5vdEVzdGFibGlzaEJyb3dzZXJDb25uZWN0aW9uKTtcbiAgICAgICAgY29uc3QgcmVhZHlUaW1lb3V0ID0gYXdhaXQgdGhpcy5fZ2V0UmVhZHlUaW1lb3V0KCk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5fY3JlYXRlUGVuZGluZ0Nvbm5lY3Rpb25Qcm9taXNlKGNvbm5lY3Rpb25zUmVhZHlQcm9taXNlLCByZWFkeVRpbWVvdXQsIHRpbWVvdXRFcnJvcik7XG4gICAgfVxuXG4gICAgX2NoZWNrRm9yRGlzY29ubmVjdGlvbnMgKCkge1xuICAgICAgICBjb25zdCBkaXNjb25uZWN0ZWRVc2VyQWdlbnRzID0gdGhpcy5icm93c2VyQ29ubmVjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoYmMgPT4gYmMuY2xvc2VkKVxuICAgICAgICAgICAgLm1hcChiYyA9PiBiYy51c2VyQWdlbnQpO1xuXG4gICAgICAgIGlmIChkaXNjb25uZWN0ZWRVc2VyQWdlbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMuY2Fubm90UnVuQWdhaW5zdERpc2Nvbm5lY3RlZEJyb3dzZXJzLCBkaXNjb25uZWN0ZWRVc2VyQWdlbnRzLmpvaW4oJywgJykpO1xuICAgIH1cblxuXG4gICAgLy9BUElcbiAgICBzdGF0aWMgZnJvbSAoYnJvd3NlckNvbm5lY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IGJyb3dzZXJTZXQgPSBuZXcgQnJvd3NlclNldChicm93c2VyQ29ubmVjdGlvbnMpO1xuXG4gICAgICAgIGNvbnN0IHByZXBhcmVDb25uZWN0aW9uID0gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBicm93c2VyU2V0Ll9jaGVja0ZvckRpc2Nvbm5lY3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXJTZXQuX3dhaXRDb25uZWN0aW9uc09wZW5lZCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IGJyb3dzZXJTZXQpO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlXG4gICAgICAgICAgICAucmFjZShbXG4gICAgICAgICAgICAgICAgcHJlcGFyZUNvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgcHJvbWlzaWZ5RXZlbnQoYnJvd3NlclNldCwgJ2Vycm9yJylcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAuY2F0Y2goYXN5bmMgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IGJyb3dzZXJTZXQuZGlzcG9zZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZWxlYXNlQ29ubmVjdGlvbiAoYmMpIHtcbiAgICAgICAgaWYgKHRoaXMuYnJvd3NlckNvbm5lY3Rpb25zLmluZGV4T2YoYmMpIDwgMClcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgICAgICByZW1vdmUodGhpcy5icm93c2VyQ29ubmVjdGlvbnMsIGJjKTtcblxuICAgICAgICBiYy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCB0aGlzLmJyb3dzZXJFcnJvckhhbmRsZXIpO1xuXG4gICAgICAgIGNvbnN0IGFwcHJvcHJpYXRlU3RhdGVTd2l0Y2ggPSAhYmMucGVybWFuZW50ID9cbiAgICAgICAgICAgIEJyb3dzZXJTZXQuX2Nsb3NlQ29ubmVjdGlvbihiYykgOlxuICAgICAgICAgICAgQnJvd3NlclNldC5fd2FpdElkbGUoYmMpO1xuXG4gICAgICAgIGNvbnN0IHJlbGVhc2UgPSBnZXRUaW1lTGltaXRlZFByb21pc2UoYXBwcm9wcmlhdGVTdGF0ZVN3aXRjaCwgdGhpcy5SRUxFQVNFX1RJTUVPVVQpLnRoZW4oKCkgPT4gcmVtb3ZlKHRoaXMucGVuZGluZ1JlbGVhc2VzLCByZWxlYXNlKSk7XG5cbiAgICAgICAgdGhpcy5wZW5kaW5nUmVsZWFzZXMucHVzaChyZWxlYXNlKTtcblxuICAgICAgICByZXR1cm4gcmVsZWFzZTtcbiAgICB9XG5cbiAgICBhc3luYyBkaXNwb3NlICgpIHtcbiAgICAgICAgLy8gTk9URTogV2hlbiBicm93c2VyQ29ubmVjdGlvbiBpcyBjYW5jZWxsZWQsIGl0IGlzIHJlbW92ZWQgZnJvbVxuICAgICAgICAvLyB0aGUgdGhpcy5jb25uZWN0aW9ucyBhcnJheSwgd2hpY2ggbGVhZHMgdG8gc2hpZnRpbmcgaW5kZXhlc1xuICAgICAgICAvLyB0b3dhcmRzIHRoZSBiZWdpbm5pbmcuIFNvLCB3ZSBtdXN0IGNvcHkgdGhlIGFycmF5IGluIG9yZGVyIHRvIGl0ZXJhdGUgaXQsXG4gICAgICAgIC8vIG9yIHdlIGNhbiBwZXJmb3JtIGl0ZXJhdGlvbiBmcm9tIHRoZSBlbmQgdG8gdGhlIGJlZ2lubmluZy5cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbnNSZWFkeVRpbWVvdXQpXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zUmVhZHlUaW1lb3V0LnVucmVmKCk7XG5cbiAgICAgICAgbWFwUmV2ZXJzZSh0aGlzLmJyb3dzZXJDb25uZWN0aW9ucywgYmMgPT4gdGhpcy5yZWxlYXNlQ29ubmVjdGlvbihiYykpO1xuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMucGVuZGluZ1JlbGVhc2VzKTtcbiAgICB9XG59XG4iXX0=
