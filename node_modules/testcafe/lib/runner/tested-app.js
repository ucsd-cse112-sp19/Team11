"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const path_1 = require("path");
const pinkie_1 = __importDefault(require("pinkie"));
const tree_kill_1 = __importDefault(require("tree-kill"));
const os_family_1 = __importDefault(require("os-family"));
const delay_1 = __importDefault(require("../utils/delay"));
const runtime_1 = require("../errors/runtime");
const types_1 = require("../errors/types");
const resolve_path_relatively_cwd_1 = __importDefault(require("../utils/resolve-path-relatively-cwd"));
const MODULES_BIN_DIR = resolve_path_relatively_cwd_1.default('./node_modules/.bin');
const ENV_PATH_KEY = (function () {
    if (os_family_1.default.win) {
        let pathKey = 'Path';
        Object.keys(process.env).forEach(key => {
            if (key.toLowerCase() === 'path')
                pathKey = key;
        });
        return pathKey;
    }
    return 'PATH';
})();
class TestedApp {
    constructor() {
        this.process = null;
        this.errorPromise = null;
        this.killed = false;
    }
    async start(command, initDelay) {
        this.errorPromise = new pinkie_1.default((resolve, reject) => {
            const env = Object.assign({}, process.env);
            const path = env[ENV_PATH_KEY] || '';
            const pathParts = path.split(path_1.delimiter);
            pathParts.unshift(MODULES_BIN_DIR);
            env[ENV_PATH_KEY] = pathParts.join(path_1.delimiter);
            this.process = child_process_1.exec(command, { env }, err => {
                if (!this.killed && err) {
                    const message = err.stack || String(err);
                    reject(new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.testedAppFailedWithError, message));
                }
            });
        });
        await pinkie_1.default.race([
            delay_1.default(initDelay),
            this.errorPromise
        ]);
    }
    async kill() {
        this.killed = true;
        const killPromise = new pinkie_1.default(resolve => tree_kill_1.default(this.process.pid, 'SIGTERM', resolve));
        await killPromise;
    }
}
exports.default = TestedApp;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdGVkLWFwcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydW5uZXIvdGVzdGVkLWFwcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlEQUFxQztBQUNyQywrQkFBa0Q7QUFDbEQsb0RBQTZCO0FBQzdCLDBEQUE2QjtBQUM3QiwwREFBMkI7QUFDM0IsMkRBQW1DO0FBQ25DLCtDQUFpRDtBQUNqRCwyQ0FBaUQ7QUFDakQsdUdBQTRFO0FBRTVFLE1BQU0sZUFBZSxHQUFHLHFDQUF3QixDQUFDLHFCQUFxQixDQUFDLENBQUM7QUFFeEUsTUFBTSxZQUFZLEdBQUcsQ0FBQztJQUNsQixJQUFJLG1CQUFFLENBQUMsR0FBRyxFQUFFO1FBQ1IsSUFBSSxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBRXJCLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNuQyxJQUFJLEdBQUcsQ0FBQyxXQUFXLEVBQUUsS0FBSyxNQUFNO2dCQUM1QixPQUFPLEdBQUcsR0FBRyxDQUFDO1FBQ3RCLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxPQUFPLENBQUM7S0FDbEI7SUFFRCxPQUFPLE1BQU0sQ0FBQztBQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDO0FBR0wsTUFBcUIsU0FBUztJQUMxQjtRQUNJLElBQUksQ0FBQyxPQUFPLEdBQVEsSUFBSSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxNQUFNLEdBQVMsS0FBSyxDQUFDO0lBQzlCLENBQUM7SUFFRCxLQUFLLENBQUMsS0FBSyxDQUFFLE9BQU8sRUFBRSxTQUFTO1FBQzNCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxnQkFBTyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBQ2hELE1BQU0sR0FBRyxHQUFTLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqRCxNQUFNLElBQUksR0FBUSxHQUFHLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQzFDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWEsQ0FBQyxDQUFDO1lBRTVDLFNBQVMsQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7WUFFbkMsR0FBRyxDQUFDLFlBQVksQ0FBQyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsZ0JBQWEsQ0FBQyxDQUFDO1lBRWxELElBQUksQ0FBQyxPQUFPLEdBQUcsb0JBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxHQUFHLENBQUMsRUFBRTtnQkFDeEMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksR0FBRyxFQUFFO29CQUNyQixNQUFNLE9BQU8sR0FBRyxHQUFHLENBQUMsS0FBSyxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFFekMsTUFBTSxDQUFDLElBQUksc0JBQVksQ0FBQyxzQkFBYyxDQUFDLHdCQUF3QixFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7aUJBQzlFO1lBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztRQUVILE1BQU0sZ0JBQU8sQ0FBQyxJQUFJLENBQUM7WUFDZixlQUFLLENBQUMsU0FBUyxDQUFDO1lBQ2hCLElBQUksQ0FBQyxZQUFZO1NBQ3BCLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRCxLQUFLLENBQUMsSUFBSTtRQUNOLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO1FBRW5CLE1BQU0sV0FBVyxHQUFHLElBQUksZ0JBQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLG1CQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFFdkYsTUFBTSxXQUFXLENBQUM7SUFDdEIsQ0FBQztDQUNKO0FBdkNELDRCQXVDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4ZWMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IGRlbGltaXRlciBhcyBwYXRoRGVsaW1pdGVyIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICdwaW5raWUnO1xuaW1wb3J0IGtpbGwgZnJvbSAndHJlZS1raWxsJztcbmltcG9ydCBPUyBmcm9tICdvcy1mYW1pbHknO1xuaW1wb3J0IGRlbGF5IGZyb20gJy4uL3V0aWxzL2RlbGF5JztcbmltcG9ydCB7IEdlbmVyYWxFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9ydW50aW1lJztcbmltcG9ydCB7IFJVTlRJTUVfRVJST1JTIH0gZnJvbSAnLi4vZXJyb3JzL3R5cGVzJztcbmltcG9ydCByZXNvbHZlUGF0aFJlbGF0aXZlbHlDd2QgZnJvbSAnLi4vdXRpbHMvcmVzb2x2ZS1wYXRoLXJlbGF0aXZlbHktY3dkJztcblxuY29uc3QgTU9EVUxFU19CSU5fRElSID0gcmVzb2x2ZVBhdGhSZWxhdGl2ZWx5Q3dkKCcuL25vZGVfbW9kdWxlcy8uYmluJyk7XG5cbmNvbnN0IEVOVl9QQVRIX0tFWSA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKE9TLndpbikge1xuICAgICAgICBsZXQgcGF0aEtleSA9ICdQYXRoJztcblxuICAgICAgICBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSAncGF0aCcpXG4gICAgICAgICAgICAgICAgcGF0aEtleSA9IGtleTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGhLZXk7XG4gICAgfVxuXG4gICAgcmV0dXJuICdQQVRIJztcbn0pKCk7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVzdGVkQXBwIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgIHRoaXMucHJvY2VzcyAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5lcnJvclByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmtpbGxlZCAgICAgICA9IGZhbHNlO1xuICAgIH1cblxuICAgIGFzeW5jIHN0YXJ0IChjb21tYW5kLCBpbml0RGVsYXkpIHtcbiAgICAgICAgdGhpcy5lcnJvclByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbnYgICAgICAgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzLmVudik7XG4gICAgICAgICAgICBjb25zdCBwYXRoICAgICAgPSBlbnZbRU5WX1BBVEhfS0VZXSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHBhdGhQYXJ0cyA9IHBhdGguc3BsaXQocGF0aERlbGltaXRlcik7XG5cbiAgICAgICAgICAgIHBhdGhQYXJ0cy51bnNoaWZ0KE1PRFVMRVNfQklOX0RJUik7XG5cbiAgICAgICAgICAgIGVudltFTlZfUEFUSF9LRVldID0gcGF0aFBhcnRzLmpvaW4ocGF0aERlbGltaXRlcik7XG5cbiAgICAgICAgICAgIHRoaXMucHJvY2VzcyA9IGV4ZWMoY29tbWFuZCwgeyBlbnYgfSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMua2lsbGVkICYmIGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyLnN0YWNrIHx8IFN0cmluZyhlcnIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgR2VuZXJhbEVycm9yKFJVTlRJTUVfRVJST1JTLnRlc3RlZEFwcEZhaWxlZFdpdGhFcnJvciwgbWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgZGVsYXkoaW5pdERlbGF5KSxcbiAgICAgICAgICAgIHRoaXMuZXJyb3JQcm9taXNlXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIGFzeW5jIGtpbGwgKCkge1xuICAgICAgICB0aGlzLmtpbGxlZCA9IHRydWU7XG5cbiAgICAgICAgY29uc3Qga2lsbFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IGtpbGwodGhpcy5wcm9jZXNzLnBpZCwgJ1NJR1RFUk0nLCByZXNvbHZlKSk7XG5cbiAgICAgICAgYXdhaXQga2lsbFByb21pc2U7XG4gICAgfVxufVxuIl19