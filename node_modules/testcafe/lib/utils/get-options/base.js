"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const pinkie_1 = __importDefault(require("pinkie"));
const convert_to_best_fit_type_1 = __importDefault(require("../convert-to-best-fit-type"));
const DEFAULT_OPTIONS_SEPARATOR = ',';
const DEFAULT_KEY_VALUE_SEPARATOR = '=';
function convertOptionValueType(value) {
    // NOTE: threat a key without a separator and a value as a boolean flag
    if (value === void 0)
        return true;
    return convert_to_best_fit_type_1.default(value);
}
function parseOptionsString(optionsStr, optionsSeparator, keyValueSeparator) {
    return optionsStr
        .split(optionsSeparator)
        .map(keyValueString => keyValueString.split(keyValueSeparator))
        .map(([key, ...value]) => [key, value.length > 1 ? value.join(keyValueSeparator) : value[0]]);
}
async function default_1(sourceOptions = '', optionsConfig) {
    const { optionsSeparator = DEFAULT_OPTIONS_SEPARATOR, keyValueSeparator = DEFAULT_KEY_VALUE_SEPARATOR, skipOptionValueTypeConversion = false, onOptionParsed = void 0, } = optionsConfig;
    const optionsList = typeof sourceOptions === 'string' ?
        parseOptionsString(sourceOptions, optionsSeparator, keyValueSeparator) :
        Object.entries(sourceOptions);
    const resultOptions = {};
    await pinkie_1.default.all(optionsList.map(async ([key, value]) => {
        if (!skipOptionValueTypeConversion)
            value = convertOptionValueType(value);
        if (onOptionParsed)
            value = await onOptionParsed(key, value);
        resultOptions[key] = value;
    }));
    return resultOptions;
}
exports.default = default_1;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9nZXQtb3B0aW9ucy9iYXNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsb0RBQTZCO0FBQzdCLDJGQUErRDtBQUcvRCxNQUFNLHlCQUF5QixHQUFLLEdBQUcsQ0FBQztBQUN4QyxNQUFNLDJCQUEyQixHQUFHLEdBQUcsQ0FBQztBQUd4QyxTQUFTLHNCQUFzQixDQUFFLEtBQUs7SUFDbEMsdUVBQXVFO0lBQ3ZFLElBQUksS0FBSyxLQUFLLEtBQUssQ0FBQztRQUNoQixPQUFPLElBQUksQ0FBQztJQUVoQixPQUFPLGtDQUFvQixDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3ZDLENBQUM7QUFFRCxTQUFTLGtCQUFrQixDQUFFLFVBQVUsRUFBRSxnQkFBZ0IsRUFBRSxpQkFBaUI7SUFDeEUsT0FBTyxVQUFVO1NBQ1osS0FBSyxDQUFDLGdCQUFnQixDQUFDO1NBQ3ZCLEdBQUcsQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztTQUM5RCxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RHLENBQUM7QUFFYyxLQUFLLG9CQUFXLGFBQWEsR0FBRyxFQUFFLEVBQUUsYUFBYTtJQUM1RCxNQUFNLEVBQ0YsZ0JBQWdCLEdBQUcseUJBQXlCLEVBQzVDLGlCQUFpQixHQUFHLDJCQUEyQixFQUMvQyw2QkFBNkIsR0FBRyxLQUFLLEVBQ3JDLGNBQWMsR0FBRyxLQUFLLENBQUMsR0FDMUIsR0FBRyxhQUFhLENBQUM7SUFFbEIsTUFBTSxXQUFXLEdBQUcsT0FBTyxhQUFhLEtBQUssUUFBUSxDQUFDLENBQUM7UUFDbkQsa0JBQWtCLENBQUMsYUFBYSxFQUFFLGdCQUFnQixFQUFFLGlCQUFpQixDQUFDLENBQUMsQ0FBQztRQUN4RSxNQUFNLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBRWxDLE1BQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQztJQUV6QixNQUFNLGdCQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUU7UUFDckQsSUFBSSxDQUFDLDZCQUE2QjtZQUM5QixLQUFLLEdBQUcsc0JBQXNCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFMUMsSUFBSSxjQUFjO1lBQ2QsS0FBSyxHQUFHLE1BQU0sY0FBYyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUU3QyxhQUFhLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQy9CLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFSixPQUFPLGFBQWEsQ0FBQztBQUN6QixDQUFDO0FBekJELDRCQXlCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQcm9taXNlIGZyb20gJ3BpbmtpZSc7XG5pbXBvcnQgY29udmVydFRvQmVzdEZpdFR5cGUgZnJvbSAnLi4vY29udmVydC10by1iZXN0LWZpdC10eXBlJztcblxuXG5jb25zdCBERUZBVUxUX09QVElPTlNfU0VQQVJBVE9SICAgPSAnLCc7XG5jb25zdCBERUZBVUxUX0tFWV9WQUxVRV9TRVBBUkFUT1IgPSAnPSc7XG5cblxuZnVuY3Rpb24gY29udmVydE9wdGlvblZhbHVlVHlwZSAodmFsdWUpIHtcbiAgICAvLyBOT1RFOiB0aHJlYXQgYSBrZXkgd2l0aG91dCBhIHNlcGFyYXRvciBhbmQgYSB2YWx1ZSBhcyBhIGJvb2xlYW4gZmxhZ1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBjb252ZXJ0VG9CZXN0Rml0VHlwZSh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9uc1N0cmluZyAob3B0aW9uc1N0ciwgb3B0aW9uc1NlcGFyYXRvciwga2V5VmFsdWVTZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gb3B0aW9uc1N0clxuICAgICAgICAuc3BsaXQob3B0aW9uc1NlcGFyYXRvcilcbiAgICAgICAgLm1hcChrZXlWYWx1ZVN0cmluZyA9PiBrZXlWYWx1ZVN0cmluZy5zcGxpdChrZXlWYWx1ZVNlcGFyYXRvcikpXG4gICAgICAgIC5tYXAoKFtrZXksIC4uLnZhbHVlXSkgPT4gW2tleSwgdmFsdWUubGVuZ3RoID4gMSA/IHZhbHVlLmpvaW4oa2V5VmFsdWVTZXBhcmF0b3IpIDogdmFsdWVbMF1dKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gKHNvdXJjZU9wdGlvbnMgPSAnJywgb3B0aW9uc0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgICAgb3B0aW9uc1NlcGFyYXRvciA9IERFRkFVTFRfT1BUSU9OU19TRVBBUkFUT1IsXG4gICAgICAgIGtleVZhbHVlU2VwYXJhdG9yID0gREVGQVVMVF9LRVlfVkFMVUVfU0VQQVJBVE9SLFxuICAgICAgICBza2lwT3B0aW9uVmFsdWVUeXBlQ29udmVyc2lvbiA9IGZhbHNlLFxuICAgICAgICBvbk9wdGlvblBhcnNlZCA9IHZvaWQgMCxcbiAgICB9ID0gb3B0aW9uc0NvbmZpZztcblxuICAgIGNvbnN0IG9wdGlvbnNMaXN0ID0gdHlwZW9mIHNvdXJjZU9wdGlvbnMgPT09ICdzdHJpbmcnID9cbiAgICAgICAgcGFyc2VPcHRpb25zU3RyaW5nKHNvdXJjZU9wdGlvbnMsIG9wdGlvbnNTZXBhcmF0b3IsIGtleVZhbHVlU2VwYXJhdG9yKSA6XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHNvdXJjZU9wdGlvbnMpO1xuXG4gICAgY29uc3QgcmVzdWx0T3B0aW9ucyA9IHt9O1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwob3B0aW9uc0xpc3QubWFwKGFzeW5jIChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKCFza2lwT3B0aW9uVmFsdWVUeXBlQ29udmVyc2lvbilcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVydE9wdGlvblZhbHVlVHlwZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9uT3B0aW9uUGFyc2VkKVxuICAgICAgICAgICAgdmFsdWUgPSBhd2FpdCBvbk9wdGlvblBhcnNlZChrZXksIHZhbHVlKTtcblxuICAgICAgICByZXN1bHRPcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gcmVzdWx0T3B0aW9ucztcbn1cblxuIl19