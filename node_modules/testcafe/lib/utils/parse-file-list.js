'use strict';

exports.__esModule = true;

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

let getDefaultDirs = (() => {
    var _ref = (0, _asyncToGenerator3.default)(function* (baseDir) {
        return yield (0, _globby2.default)(DEFAULT_TEST_LOOKUP_DIRS, {
            cwd: baseDir,
            nocase: true,
            silent: true
        });
    });

    return function getDefaultDirs(_x) {
        return _ref.apply(this, arguments);
    };
})();

let convertDirsToGlobs = (() => {
    var _ref2 = (0, _asyncToGenerator3.default)(function* (fileList, baseDir) {
        fileList = yield _pinkie2.default.all(fileList.map((() => {
            var _ref3 = (0, _asyncToGenerator3.default)(function* (file) {
                if (!(0, _isGlob2.default)(file)) {
                    const absPath = _path2.default.resolve(baseDir, file);
                    let fileStat = null;

                    try {
                        fileStat = yield (0, _promisifiedFunctions.stat)(absPath);
                    } catch (err) {
                        return null;
                    }

                    if (fileStat.isDirectory()) return _path2.default.join(file, TEST_FILE_GLOB_PATTERN);

                    if (_osFamily2.default.win) file = modifyFileRoot(baseDir, file);
                }

                return file;
            });

            return function (_x4) {
                return _ref3.apply(this, arguments);
            };
        })()));

        return fileList.filter(function (file) {
            return !!file;
        });
    });

    return function convertDirsToGlobs(_x2, _x3) {
        return _ref2.apply(this, arguments);
    };
})();

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _globby = require('globby');

var _globby2 = _interopRequireDefault(_globby);

var _isGlob = require('is-glob');

var _isGlob2 = _interopRequireDefault(_isGlob);

var _compiler = require('../compiler');

var _compiler2 = _interopRequireDefault(_compiler);

var _osFamily = require('os-family');

var _osFamily2 = _interopRequireDefault(_osFamily);

var _lodash = require('lodash');

var _promisifiedFunctions = require('../utils/promisified-functions');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_TEST_LOOKUP_DIRS = ['test/', 'tests/'];
const TEST_FILE_GLOB_PATTERN = `./**/*@(${_compiler2.default.getSupportedTestFileExtensions().join('|')})`;

function modifyFileRoot(baseDir, file) {
    const absPath = _path2.default.resolve(baseDir, file);
    const fileIsOnOtherDrive = _path2.default.isAbsolute(_path2.default.relative(baseDir, file));

    if (!_path2.default.isAbsolute(file) || fileIsOnOtherDrive) return file;

    var _path$parse = _path2.default.parse(absPath);

    const root = _path$parse.root,
          dir = _path$parse.dir,
          base = _path$parse.base;


    return _path2.default.join(_path2.default.parse(baseDir).root, _path2.default.relative(root, dir), base);
}

exports.default = (() => {
    var _ref4 = (0, _asyncToGenerator3.default)(function* (fileList, baseDir) {
        if ((0, _lodash.isEmpty)(fileList)) fileList = yield getDefaultDirs(baseDir);

        fileList = yield convertDirsToGlobs(fileList, baseDir);
        fileList = yield (0, _globby2.default)(fileList, { cwd: baseDir });

        return fileList.map(function (file) {
            return _path2.default.resolve(baseDir, file);
        });
    });

    function parseFileList(_x5, _x6) {
        return _ref4.apply(this, arguments);
    }

    return parseFileList;
})();

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9wYXJzZS1maWxlLWxpc3QuanMiXSwibmFtZXMiOlsiYmFzZURpciIsIkRFRkFVTFRfVEVTVF9MT09LVVBfRElSUyIsImN3ZCIsIm5vY2FzZSIsInNpbGVudCIsImdldERlZmF1bHREaXJzIiwiZmlsZUxpc3QiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiZmlsZSIsImFic1BhdGgiLCJwYXRoIiwicmVzb2x2ZSIsImZpbGVTdGF0IiwiZXJyIiwiaXNEaXJlY3RvcnkiLCJqb2luIiwiVEVTVF9GSUxFX0dMT0JfUEFUVEVSTiIsIk9TIiwid2luIiwibW9kaWZ5RmlsZVJvb3QiLCJmaWx0ZXIiLCJjb252ZXJ0RGlyc1RvR2xvYnMiLCJDb21waWxlciIsImdldFN1cHBvcnRlZFRlc3RGaWxlRXh0ZW5zaW9ucyIsImZpbGVJc09uT3RoZXJEcml2ZSIsImlzQWJzb2x1dGUiLCJyZWxhdGl2ZSIsInBhcnNlIiwicm9vdCIsImRpciIsImJhc2UiLCJwYXJzZUZpbGVMaXN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7K0NBd0JBLFdBQStCQSxPQUEvQixFQUF3QztBQUNwQyxlQUFPLE1BQU0sc0JBQU9DLHdCQUFQLEVBQWlDO0FBQzFDQyxpQkFBUUYsT0FEa0M7QUFFMUNHLG9CQUFRLElBRmtDO0FBRzFDQyxvQkFBUTtBQUhrQyxTQUFqQyxDQUFiO0FBS0gsSzs7b0JBTmNDLGM7Ozs7OztnREFRZixXQUFtQ0MsUUFBbkMsRUFBNkNOLE9BQTdDLEVBQXNEO0FBQ2xETSxtQkFBVyxNQUFNQyxpQkFBUUMsR0FBUixDQUFZRixTQUFTRyxHQUFUO0FBQUEsd0RBQWEsV0FBTUMsSUFBTixFQUFjO0FBQ3BELG9CQUFJLENBQUMsc0JBQU9BLElBQVAsQ0FBTCxFQUFtQjtBQUNmLDBCQUFNQyxVQUFVQyxlQUFLQyxPQUFMLENBQWFiLE9BQWIsRUFBc0JVLElBQXRCLENBQWhCO0FBQ0Esd0JBQUlJLFdBQVksSUFBaEI7O0FBRUEsd0JBQUk7QUFDQUEsbUNBQVcsTUFBTSxnQ0FBS0gsT0FBTCxDQUFqQjtBQUNILHFCQUZELENBR0EsT0FBT0ksR0FBUCxFQUFZO0FBQ1IsK0JBQU8sSUFBUDtBQUNIOztBQUVELHdCQUFJRCxTQUFTRSxXQUFULEVBQUosRUFDSSxPQUFPSixlQUFLSyxJQUFMLENBQVVQLElBQVYsRUFBZ0JRLHNCQUFoQixDQUFQOztBQUVKLHdCQUFJQyxtQkFBR0MsR0FBUCxFQUNJVixPQUFPVyxlQUFlckIsT0FBZixFQUF3QlUsSUFBeEIsQ0FBUDtBQUNQOztBQUVELHVCQUFPQSxJQUFQO0FBQ0gsYUFwQjRCOztBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQVosQ0FBakI7O0FBc0JBLGVBQU9KLFNBQVNnQixNQUFULENBQWdCO0FBQUEsbUJBQVEsQ0FBQyxDQUFDWixJQUFWO0FBQUEsU0FBaEIsQ0FBUDtBQUNILEs7O29CQXhCY2Esa0I7Ozs7O0FBaENmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBRUEsTUFBTXRCLDJCQUEyQixDQUFDLE9BQUQsRUFBVSxRQUFWLENBQWpDO0FBQ0EsTUFBTWlCLHlCQUE0QixXQUFVTSxtQkFBU0MsOEJBQVQsR0FBMENSLElBQTFDLENBQStDLEdBQS9DLENBQW9ELEdBQWhHOztBQUVBLFNBQVNJLGNBQVQsQ0FBeUJyQixPQUF6QixFQUFrQ1UsSUFBbEMsRUFBd0M7QUFDcEMsVUFBTUMsVUFBcUJDLGVBQUtDLE9BQUwsQ0FBYWIsT0FBYixFQUFzQlUsSUFBdEIsQ0FBM0I7QUFDQSxVQUFNZ0IscUJBQXFCZCxlQUFLZSxVQUFMLENBQWdCZixlQUFLZ0IsUUFBTCxDQUFjNUIsT0FBZCxFQUF1QlUsSUFBdkIsQ0FBaEIsQ0FBM0I7O0FBRUEsUUFBSSxDQUFDRSxlQUFLZSxVQUFMLENBQWdCakIsSUFBaEIsQ0FBRCxJQUEwQmdCLGtCQUE5QixFQUNJLE9BQU9oQixJQUFQOztBQUxnQyxzQkFPUkUsZUFBS2lCLEtBQUwsQ0FBV2xCLE9BQVgsQ0FQUTs7QUFBQSxVQU81Qm1CLElBUDRCLGVBTzVCQSxJQVA0QjtBQUFBLFVBT3RCQyxHQVBzQixlQU90QkEsR0FQc0I7QUFBQSxVQU9qQkMsSUFQaUIsZUFPakJBLElBUGlCOzs7QUFTcEMsV0FBT3BCLGVBQUtLLElBQUwsQ0FBVUwsZUFBS2lCLEtBQUwsQ0FBVzdCLE9BQVgsRUFBb0I4QixJQUE5QixFQUFvQ2xCLGVBQUtnQixRQUFMLENBQWNFLElBQWQsRUFBb0JDLEdBQXBCLENBQXBDLEVBQThEQyxJQUE5RCxDQUFQO0FBQ0g7OztnREFvQ2MsV0FBOEIxQixRQUE5QixFQUF3Q04sT0FBeEMsRUFBaUQ7QUFDNUQsWUFBSSxxQkFBUU0sUUFBUixDQUFKLEVBQ0lBLFdBQVcsTUFBTUQsZUFBZUwsT0FBZixDQUFqQjs7QUFFSk0sbUJBQVcsTUFBTWlCLG1CQUFtQmpCLFFBQW5CLEVBQTZCTixPQUE3QixDQUFqQjtBQUNBTSxtQkFBVyxNQUFNLHNCQUFPQSxRQUFQLEVBQWlCLEVBQUVKLEtBQUtGLE9BQVAsRUFBakIsQ0FBakI7O0FBRUEsZUFBT00sU0FBU0csR0FBVCxDQUFhO0FBQUEsbUJBQVFHLGVBQUtDLE9BQUwsQ0FBYWIsT0FBYixFQUFzQlUsSUFBdEIsQ0FBUjtBQUFBLFNBQWIsQ0FBUDtBQUNILEs7O2FBUjZCdUIsYTs7OztXQUFBQSxhIiwiZmlsZSI6InV0aWxzL3BhcnNlLWZpbGUtbGlzdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAncGlua2llJztcbmltcG9ydCBnbG9iYnkgZnJvbSAnZ2xvYmJ5JztcbmltcG9ydCBpc0dsb2IgZnJvbSAnaXMtZ2xvYic7XG5pbXBvcnQgQ29tcGlsZXIgZnJvbSAnLi4vY29tcGlsZXInO1xuaW1wb3J0IE9TIGZyb20gJ29zLWZhbWlseSc7XG5pbXBvcnQgeyBpc0VtcHR5IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHN0YXQgfSBmcm9tICcuLi91dGlscy9wcm9taXNpZmllZC1mdW5jdGlvbnMnO1xuXG5jb25zdCBERUZBVUxUX1RFU1RfTE9PS1VQX0RJUlMgPSBbJ3Rlc3QvJywgJ3Rlc3RzLyddO1xuY29uc3QgVEVTVF9GSUxFX0dMT0JfUEFUVEVSTiAgID0gYC4vKiovKkAoJHtDb21waWxlci5nZXRTdXBwb3J0ZWRUZXN0RmlsZUV4dGVuc2lvbnMoKS5qb2luKCd8Jyl9KWA7XG5cbmZ1bmN0aW9uIG1vZGlmeUZpbGVSb290IChiYXNlRGlyLCBmaWxlKSB7XG4gICAgY29uc3QgYWJzUGF0aCAgICAgICAgICAgID0gcGF0aC5yZXNvbHZlKGJhc2VEaXIsIGZpbGUpO1xuICAgIGNvbnN0IGZpbGVJc09uT3RoZXJEcml2ZSA9IHBhdGguaXNBYnNvbHV0ZShwYXRoLnJlbGF0aXZlKGJhc2VEaXIsIGZpbGUpKTtcblxuICAgIGlmICghcGF0aC5pc0Fic29sdXRlKGZpbGUpIHx8IGZpbGVJc09uT3RoZXJEcml2ZSlcbiAgICAgICAgcmV0dXJuIGZpbGU7XG5cbiAgICBjb25zdCB7IHJvb3QsIGRpciwgYmFzZSB9ID0gcGF0aC5wYXJzZShhYnNQYXRoKTtcblxuICAgIHJldHVybiBwYXRoLmpvaW4ocGF0aC5wYXJzZShiYXNlRGlyKS5yb290LCBwYXRoLnJlbGF0aXZlKHJvb3QsIGRpciksIGJhc2UpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXREZWZhdWx0RGlycyAoYmFzZURpcikge1xuICAgIHJldHVybiBhd2FpdCBnbG9iYnkoREVGQVVMVF9URVNUX0xPT0tVUF9ESVJTLCB7XG4gICAgICAgIGN3ZDogICAgYmFzZURpcixcbiAgICAgICAgbm9jYXNlOiB0cnVlLFxuICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY29udmVydERpcnNUb0dsb2JzIChmaWxlTGlzdCwgYmFzZURpcikge1xuICAgIGZpbGVMaXN0ID0gYXdhaXQgUHJvbWlzZS5hbGwoZmlsZUxpc3QubWFwKGFzeW5jIGZpbGUgPT4ge1xuICAgICAgICBpZiAoIWlzR2xvYihmaWxlKSkge1xuICAgICAgICAgICAgY29uc3QgYWJzUGF0aCA9IHBhdGgucmVzb2x2ZShiYXNlRGlyLCBmaWxlKTtcbiAgICAgICAgICAgIGxldCBmaWxlU3RhdCAgPSBudWxsO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZpbGVTdGF0ID0gYXdhaXQgc3RhdChhYnNQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZpbGVTdGF0LmlzRGlyZWN0b3J5KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGguam9pbihmaWxlLCBURVNUX0ZJTEVfR0xPQl9QQVRURVJOKTtcblxuICAgICAgICAgICAgaWYgKE9TLndpbilcbiAgICAgICAgICAgICAgICBmaWxlID0gbW9kaWZ5RmlsZVJvb3QoYmFzZURpciwgZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZmlsZUxpc3QuZmlsdGVyKGZpbGUgPT4gISFmaWxlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGFyc2VGaWxlTGlzdCAoZmlsZUxpc3QsIGJhc2VEaXIpIHtcbiAgICBpZiAoaXNFbXB0eShmaWxlTGlzdCkpXG4gICAgICAgIGZpbGVMaXN0ID0gYXdhaXQgZ2V0RGVmYXVsdERpcnMoYmFzZURpcik7XG5cbiAgICBmaWxlTGlzdCA9IGF3YWl0IGNvbnZlcnREaXJzVG9HbG9icyhmaWxlTGlzdCwgYmFzZURpcik7XG4gICAgZmlsZUxpc3QgPSBhd2FpdCBnbG9iYnkoZmlsZUxpc3QsIHsgY3dkOiBiYXNlRGlyIH0pO1xuXG4gICAgcmV0dXJuIGZpbGVMaXN0Lm1hcChmaWxlID0+IHBhdGgucmVzb2x2ZShiYXNlRGlyLCBmaWxlKSk7XG59XG4iXX0=
