'use strict';

exports.__esModule = true;
exports.killBrowserProcess = undefined;

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

let findProcessUnix = (() => {
    var _ref = (0, _asyncToGenerator3.default)(function* (browserId) {
        const output = yield getProcessOutputUnix();

        return findProcessIdUnix(browserId, output);
    });

    return function findProcessUnix(_x) {
        return _ref.apply(this, arguments);
    };
})();

let checkUnixProcessIsKilled = (() => {
    var _ref2 = (0, _asyncToGenerator3.default)(function* (processId) {
        const output = yield getProcessOutputUnix();

        if (isProcessExistUnix(processId, output)) {
            yield (0, _delay2.default)(CHECK_KILLED_DELAY);

            yield checkUnixProcessIsKilled();
        }
    });

    return function checkUnixProcessIsKilled(_x2) {
        return _ref2.apply(this, arguments);
    };
})();

let killProcessUnix = (() => {
    var _ref3 = (0, _asyncToGenerator3.default)(function* (processId) {
        let timeoutError = false;

        process.kill(processId);

        const killTimeoutTimer = (0, _delay2.default)(CHECK_PROCESS_IS_KILLED_TIMEOUT).then(function () {
            timeoutError = true;
        });

        return _pinkie2.default.race([killTimeoutTimer, checkUnixProcessIsKilled(processId)]).then(function () {
            if (timeoutError) throw new Error(killProcessTimeoutError);
        });
    });

    return function killProcessUnix(_x3) {
        return _ref3.apply(this, arguments);
    };
})();

let runWMIC = (() => {
    var _ref4 = (0, _asyncToGenerator3.default)(function* (args) {
        const wmicProcess = (0, _child_process.spawn)('wmic.exe', args, { detached: true });

        let wmicOutput = '';

        wmicProcess.stdout.on('data', function (data) {
            wmicOutput += data.toString();
        });

        try {
            yield _pinkie2.default.race([(0, _promisifyEvent2.default)(wmicProcess.stdout, 'end'), (0, _promisifyEvent2.default)(wmicProcess, 'error')]);

            return wmicOutput;
        } catch (e) {
            return '';
        }
    });

    return function runWMIC(_x4) {
        return _ref4.apply(this, arguments);
    };
})();

let findProcessWin = (() => {
    var _ref5 = (0, _asyncToGenerator3.default)(function* (browserId) {
        const wmicArgs = ['process', 'where', `commandline like '%${browserId}%' and name <> 'cmd.exe' and name <> 'wmic.exe'`, 'get', 'processid'];
        const wmicOutput = yield runWMIC(wmicArgs);
        let processList = wmicOutput.split(/\s*\n/);

        processList = processList
        // NOTE: remove list's header and empty last element, caused by trailing newline
        .slice(1, -1).map(function (pid) {
            return { pid: Number(pid) };
        });

        return processList[0] ? processList[0].pid : null;
    });

    return function findProcessWin(_x5) {
        return _ref5.apply(this, arguments);
    };
})();

let killBrowserProcess = exports.killBrowserProcess = (() => {
    var _ref6 = (0, _asyncToGenerator3.default)(function* (browserId) {
        const processId = _osFamily2.default.win ? yield findProcessWin(browserId) : yield findProcessUnix(browserId);

        if (!processId) return true;

        try {
            if (_osFamily2.default.win) process.kill(processId);else yield killProcessUnix(processId);

            return true;
        } catch (e) {
            return false;
        }
    });

    return function killBrowserProcess(_x6) {
        return _ref6.apply(this, arguments);
    };
})();

var _child_process = require('child_process');

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _osFamily = require('os-family');

var _osFamily2 = _interopRequireDefault(_osFamily);

var _promisifyEvent = require('promisify-event');

var _promisifyEvent2 = _interopRequireDefault(_promisifyEvent);

var _delay = require('../utils/delay');

var _delay2 = _interopRequireDefault(_delay);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const CHECK_PROCESS_IS_KILLED_TIMEOUT = 5000;
const CHECK_KILLED_DELAY = 1000;
const NEW_LINE_SEPERATOR_RE = /(\r\n)|(\n\r)|\n|\r/g;
const cannotGetListOfProcessError = 'Cannot get list of processes';
const killProcessTimeoutError = 'Kill process timeout';

function getProcessOutputUnix() {
    const error = new Error(cannotGetListOfProcessError);

    return new _pinkie2.default((resolve, reject) => {
        const child = (0, _child_process.spawn)('ps', ['-eo', 'pid,command']);
        let stdout = '';
        let stderr = '';

        child.stdout.on('data', data => {
            stdout += data.toString();
        });

        child.stderr.on('data', data => {
            stderr += data.toString();
        });

        child.on('exit', () => {
            if (stderr) reject(error);else resolve(stdout);
        });

        child.on('error', () => {
            reject(error);
        });
    });
}

function findProcessIdUnix(browserId, psOutput) {
    const processIdRegex = new RegExp('^\\s*(\\d+)\\s+.*' + browserId);
    const lines = psOutput.split(NEW_LINE_SEPERATOR_RE);

    for (let i = 0; i < lines.length; i++) {
        const match = processIdRegex.exec(lines[i]);

        if (match) return parseInt(match[1], 10);
    }

    return null;
}

function isProcessExistUnix(processId, psOutput) {
    const processIdRegex = new RegExp('^\\s*' + processId + '\\s+.*');
    const lines = psOutput.split(NEW_LINE_SEPERATOR_RE);

    return lines.some(line => processIdRegex.test(line));
}
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9wcm9jZXNzLmpzIl0sIm5hbWVzIjpbImJyb3dzZXJJZCIsIm91dHB1dCIsImdldFByb2Nlc3NPdXRwdXRVbml4IiwiZmluZFByb2Nlc3NJZFVuaXgiLCJmaW5kUHJvY2Vzc1VuaXgiLCJwcm9jZXNzSWQiLCJpc1Byb2Nlc3NFeGlzdFVuaXgiLCJDSEVDS19LSUxMRURfREVMQVkiLCJjaGVja1VuaXhQcm9jZXNzSXNLaWxsZWQiLCJ0aW1lb3V0RXJyb3IiLCJwcm9jZXNzIiwia2lsbCIsImtpbGxUaW1lb3V0VGltZXIiLCJDSEVDS19QUk9DRVNTX0lTX0tJTExFRF9USU1FT1VUIiwidGhlbiIsIlByb21pc2UiLCJyYWNlIiwiRXJyb3IiLCJraWxsUHJvY2Vzc1RpbWVvdXRFcnJvciIsImtpbGxQcm9jZXNzVW5peCIsImFyZ3MiLCJ3bWljUHJvY2VzcyIsImRldGFjaGVkIiwid21pY091dHB1dCIsInN0ZG91dCIsIm9uIiwiZGF0YSIsInRvU3RyaW5nIiwiZSIsInJ1bldNSUMiLCJ3bWljQXJncyIsInByb2Nlc3NMaXN0Iiwic3BsaXQiLCJzbGljZSIsIm1hcCIsInBpZCIsIk51bWJlciIsImZpbmRQcm9jZXNzV2luIiwiT1MiLCJ3aW4iLCJraWxsQnJvd3NlclByb2Nlc3MiLCJORVdfTElORV9TRVBFUkFUT1JfUkUiLCJjYW5ub3RHZXRMaXN0T2ZQcm9jZXNzRXJyb3IiLCJlcnJvciIsInJlc29sdmUiLCJyZWplY3QiLCJjaGlsZCIsInN0ZGVyciIsInBzT3V0cHV0IiwicHJvY2Vzc0lkUmVnZXgiLCJSZWdFeHAiLCJsaW5lcyIsImkiLCJsZW5ndGgiLCJtYXRjaCIsImV4ZWMiLCJwYXJzZUludCIsInNvbWUiLCJsaW5lIiwidGVzdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OzsrQ0E4REEsV0FBZ0NBLFNBQWhDLEVBQTJDO0FBQ3ZDLGNBQU1DLFNBQVMsTUFBTUMsc0JBQXJCOztBQUVBLGVBQU9DLGtCQUFrQkgsU0FBbEIsRUFB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Q0EsVUFBTW1ELFFBQW1CSCxTQUFTaEIsS0FBVCxDQUFlUyxxQkFBZixDQUF6Qjs7QUFFQSxTQUFLLElBQUlXLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsTUFBTUUsTUFBMUIsRUFBa0NELEdBQWxDLEVBQXVDO0FBQ25DLGNBQU1FLFFBQVFMLGVBQWVNLElBQWYsQ0FBb0JKLE1BQU1DLENBQU4sQ0FBcEIsQ0FBZDs7QUFFQSxZQUFJRSxLQUFKLEVBQ0ksT0FBT0UsU0FBU0YsTUFBTSxDQUFOLENBQVQsRUFBbUIsRUFBbkIsQ0FBUDtBQUNQOztBQUVELFdBQU8sSUFBUDtBQUNIOztBQUVELFNBQVNoRCxrQkFBVCxDQUE2QkQsU0FBN0IsRUFBd0MyQyxRQUF4QyxFQUFrRDtBQUM5QyxVQUFNQyxpQkFBbUIsSUFBSUMsTUFBSixDQUFXLFVBQVU3QyxTQUFWLEdBQXNCLFFBQWpDLENBQXpCO0FBQ0EsVUFBTThDLFFBQW1CSCxTQUFTaEIsS0FBVCxDQUFlUyxxQkFBZixDQUF6Qjs7QUFFQSxXQUFPVSxNQUFNTSxJQUFOLENBQVdDLFFBQVFULGVBQWVVLElBQWYsQ0FBb0JELElBQXBCLENBQW5CLENBQVA7QUFDSCIsImZpbGUiOiJ1dGlscy9wcm9jZXNzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCBQcm9taXNlIGZyb20gJ3BpbmtpZSc7XG5pbXBvcnQgT1MgZnJvbSAnb3MtZmFtaWx5JztcbmltcG9ydCBwcm9taXNpZnlFdmVudCBmcm9tICdwcm9taXNpZnktZXZlbnQnO1xuaW1wb3J0IGRlbGF5IGZyb20gJy4uL3V0aWxzL2RlbGF5JztcblxuY29uc3QgQ0hFQ0tfUFJPQ0VTU19JU19LSUxMRURfVElNRU9VVCA9IDUwMDA7XG5jb25zdCBDSEVDS19LSUxMRURfREVMQVkgICAgICAgICAgICAgID0gMTAwMDtcbmNvbnN0IE5FV19MSU5FX1NFUEVSQVRPUl9SRSAgICAgICAgICAgPSAvKFxcclxcbil8KFxcblxccil8XFxufFxcci9nO1xuY29uc3QgY2Fubm90R2V0TGlzdE9mUHJvY2Vzc0Vycm9yICAgICA9ICdDYW5ub3QgZ2V0IGxpc3Qgb2YgcHJvY2Vzc2VzJztcbmNvbnN0IGtpbGxQcm9jZXNzVGltZW91dEVycm9yICAgICAgICAgPSAnS2lsbCBwcm9jZXNzIHRpbWVvdXQnO1xuXG5mdW5jdGlvbiBnZXRQcm9jZXNzT3V0cHV0VW5peCAoKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoY2Fubm90R2V0TGlzdE9mUHJvY2Vzc0Vycm9yKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gc3Bhd24oJ3BzJywgWyctZW8nLCAncGlkLGNvbW1hbmQnXSk7XG4gICAgICAgIGxldCBzdGRvdXQgID0gJyc7XG4gICAgICAgIGxldCBzdGRlcnIgID0gJyc7XG5cbiAgICAgICAgY2hpbGQuc3Rkb3V0Lm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgICAgICBzdGRvdXQgKz0gZGF0YS50b1N0cmluZygpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjaGlsZC5zdGRlcnIub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgICAgICAgIHN0ZGVyciArPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNoaWxkLm9uKCdleGl0JywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0ZGVycilcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlc29sdmUoc3Rkb3V0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2hpbGQub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRQcm9jZXNzSWRVbml4IChicm93c2VySWQsIHBzT3V0cHV0KSB7XG4gICAgY29uc3QgcHJvY2Vzc0lkUmVnZXggICA9IG5ldyBSZWdFeHAoJ15cXFxccyooXFxcXGQrKVxcXFxzKy4qJyArIGJyb3dzZXJJZCk7XG4gICAgY29uc3QgbGluZXMgICAgICAgICAgICA9IHBzT3V0cHV0LnNwbGl0KE5FV19MSU5FX1NFUEVSQVRPUl9SRSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gcHJvY2Vzc0lkUmVnZXguZXhlYyhsaW5lc1tpXSk7XG5cbiAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzUHJvY2Vzc0V4aXN0VW5peCAocHJvY2Vzc0lkLCBwc091dHB1dCkge1xuICAgIGNvbnN0IHByb2Nlc3NJZFJlZ2V4ICAgPSBuZXcgUmVnRXhwKCdeXFxcXHMqJyArIHByb2Nlc3NJZCArICdcXFxccysuKicpO1xuICAgIGNvbnN0IGxpbmVzICAgICAgICAgICAgPSBwc091dHB1dC5zcGxpdChORVdfTElORV9TRVBFUkFUT1JfUkUpO1xuXG4gICAgcmV0dXJuIGxpbmVzLnNvbWUobGluZSA9PiBwcm9jZXNzSWRSZWdleC50ZXN0KGxpbmUpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmluZFByb2Nlc3NVbml4IChicm93c2VySWQpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBnZXRQcm9jZXNzT3V0cHV0VW5peCgpO1xuXG4gICAgcmV0dXJuIGZpbmRQcm9jZXNzSWRVbml4KGJyb3dzZXJJZCwgb3V0cHV0KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tVbml4UHJvY2Vzc0lzS2lsbGVkIChwcm9jZXNzSWQpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBnZXRQcm9jZXNzT3V0cHV0VW5peCgpO1xuXG4gICAgaWYgKGlzUHJvY2Vzc0V4aXN0VW5peChwcm9jZXNzSWQsIG91dHB1dCkpIHtcbiAgICAgICAgYXdhaXQgZGVsYXkoQ0hFQ0tfS0lMTEVEX0RFTEFZKTtcblxuICAgICAgICBhd2FpdCBjaGVja1VuaXhQcm9jZXNzSXNLaWxsZWQoKTtcbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGtpbGxQcm9jZXNzVW5peCAocHJvY2Vzc0lkKSB7XG4gICAgbGV0IHRpbWVvdXRFcnJvciA9IGZhbHNlO1xuXG4gICAgcHJvY2Vzcy5raWxsKHByb2Nlc3NJZCk7XG5cbiAgICBjb25zdCBraWxsVGltZW91dFRpbWVyID0gZGVsYXkoQ0hFQ0tfUFJPQ0VTU19JU19LSUxMRURfVElNRU9VVClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGltZW91dEVycm9yID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtraWxsVGltZW91dFRpbWVyLCBjaGVja1VuaXhQcm9jZXNzSXNLaWxsZWQocHJvY2Vzc0lkKV0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGltZW91dEVycm9yKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGtpbGxQcm9jZXNzVGltZW91dEVycm9yKTtcbiAgICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuV01JQyAoYXJncykge1xuICAgIGNvbnN0IHdtaWNQcm9jZXNzID0gc3Bhd24oJ3dtaWMuZXhlJywgYXJncywgeyBkZXRhY2hlZDogdHJ1ZSB9KTtcblxuICAgIGxldCB3bWljT3V0cHV0ICA9ICcnO1xuXG4gICAgd21pY1Byb2Nlc3Muc3Rkb3V0Lm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgIHdtaWNPdXRwdXQgKz0gZGF0YS50b1N0cmluZygpO1xuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIHByb21pc2lmeUV2ZW50KHdtaWNQcm9jZXNzLnN0ZG91dCwgJ2VuZCcpLFxuICAgICAgICAgICAgcHJvbWlzaWZ5RXZlbnQod21pY1Byb2Nlc3MsICdlcnJvcicpXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHJldHVybiB3bWljT3V0cHV0O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBmaW5kUHJvY2Vzc1dpbiAoYnJvd3NlcklkKSB7XG4gICAgY29uc3Qgd21pY0FyZ3MgICAgPSBbJ3Byb2Nlc3MnLCAnd2hlcmUnLCBgY29tbWFuZGxpbmUgbGlrZSAnJSR7YnJvd3NlcklkfSUnIGFuZCBuYW1lIDw+ICdjbWQuZXhlJyBhbmQgbmFtZSA8PiAnd21pYy5leGUnYCwgJ2dldCcsICdwcm9jZXNzaWQnXTtcbiAgICBjb25zdCB3bWljT3V0cHV0ICA9IGF3YWl0IHJ1bldNSUMod21pY0FyZ3MpO1xuICAgIGxldCBwcm9jZXNzTGlzdCA9IHdtaWNPdXRwdXQuc3BsaXQoL1xccypcXG4vKTtcblxuICAgIHByb2Nlc3NMaXN0ID0gcHJvY2Vzc0xpc3RcbiAgICAvLyBOT1RFOiByZW1vdmUgbGlzdCdzIGhlYWRlciBhbmQgZW1wdHkgbGFzdCBlbGVtZW50LCBjYXVzZWQgYnkgdHJhaWxpbmcgbmV3bGluZVxuICAgICAgICAuc2xpY2UoMSwgLTEpXG4gICAgICAgIC5tYXAocGlkID0+ICh7IHBpZDogTnVtYmVyKHBpZCkgfSkpO1xuXG4gICAgcmV0dXJuIHByb2Nlc3NMaXN0WzBdID8gcHJvY2Vzc0xpc3RbMF0ucGlkIDogbnVsbDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGtpbGxCcm93c2VyUHJvY2VzcyAoYnJvd3NlcklkKSB7XG4gICAgY29uc3QgcHJvY2Vzc0lkID0gT1Mud2luID8gYXdhaXQgZmluZFByb2Nlc3NXaW4oYnJvd3NlcklkKSA6IGF3YWl0IGZpbmRQcm9jZXNzVW5peChicm93c2VySWQpO1xuXG4gICAgaWYgKCFwcm9jZXNzSWQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKE9TLndpbilcbiAgICAgICAgICAgIHByb2Nlc3Mua2lsbChwcm9jZXNzSWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhd2FpdCBraWxsUHJvY2Vzc1VuaXgocHJvY2Vzc0lkKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiJdfQ==
