'use strict';

exports.__esModule = true;

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _child_process = require('child_process');

var _lodash = require('lodash');

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _asyncEventEmitter = require('../utils/async-event-emitter');

var _asyncEventEmitter2 = _interopRequireDefault(_asyncEventEmitter);

var _delay = require('../utils/delay');

var _delay2 = _interopRequireDefault(_delay);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEBUG_LOGGER_PREFIX = 'testcafe:video-recorder:process:';

const DEFAULT_OPTIONS = {
    // NOTE: don't ask confirmation for rewriting the output file
    'y': true,

    // NOTE: use the time when a frame is read from the source as its timestamp
    // IMPORTANT: must be specified before configuring the source
    'use_wallclock_as_timestamps': 1,

    // NOTE: use stdin as a source
    'i': 'pipe:0',

    // NOTE: use the H.264 video codec
    'c:v': 'libx264',

    // NOTE: use the 'ultrafast' compression preset
    'preset': 'ultrafast',

    // NOTE: use the yuv420p pixel format (the most widely supported)
    'pix_fmt': 'yuv420p',

    // NOTE: scale input frames to make the frame height divisible by 2 (yuv420p's requirement)
    'vf': 'scale=trunc(iw/2)*2:trunc(ih/2)*2',

    // NOTE: set the frame rate to 30 in the output video (the most widely supported)
    'r': 30
};

const FFMPEG_START_DELAY = 500;

class VideoRecorder extends _asyncEventEmitter2.default {
    constructor(basePath, ffmpegPath, connection, customOptions) {
        super();

        this.debugLogger = (0, _debug2.default)(DEBUG_LOGGER_PREFIX + connection.id);

        this.customOptions = customOptions;
        this.videoPath = basePath;
        this.connection = connection;
        this.ffmpegPath = ffmpegPath;
        this.ffmpegProcess = null;

        this.ffmpegStdoutBuf = '';
        this.ffmpegStderrBuf = '';

        this.ffmpegClosingPromise = null;

        this.closed = false;

        this.optionsList = this._getOptionsList();

        this.capturingPromise = null;
    }

    static _filterOption([key, value]) {
        if (value === true) return ['-' + key];

        return ['-' + key, value];
    }

    _setupFFMPEGBuffers() {
        this.ffmpegProcess.stdout.on('data', data => {
            this.ffmpegStdoutBuf += String(data);
        });

        this.ffmpegProcess.stderr.on('data', data => {
            this.ffmpegStderrBuf += String(data);
        });
    }

    _getChildProcessPromise() {
        return new _pinkie2.default((resolve, reject) => {
            this.ffmpegProcess.on('exit', resolve);
            this.ffmpegProcess.on('error', reject);
        });
    }

    _getOptionsList() {
        const optionsObject = (0, _assign2.default)({}, DEFAULT_OPTIONS, this.customOptions);

        const optionsList = (0, _lodash.flatten)((0, _entries2.default)(optionsObject).map(VideoRecorder._filterOption));

        optionsList.push(this.videoPath);

        return optionsList;
    }

    _addFrame(frameData) {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            const writingFinished = _this.ffmpegProcess.stdin.write(frameData);

            if (!writingFinished) yield new _pinkie2.default(function (r) {
                return _this.ffmpegProcess.stdin.once('drain', r);
            });
        })();
    }

    _capture() {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            while (!_this2.closed) {
                try {
                    const frame = yield _this2.connection.provider.getVideoFrameData(_this2.connection.id);

                    if (frame) {
                        yield _this2.emit('frame');
                        yield _this2._addFrame(frame);
                    }
                } catch (error) {
                    _this2.debugLogger(error);
                }
            }
        })();
    }

    init() {
        var _this3 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            _this3.ffmpegProcess = (0, _child_process.spawn)(_this3.ffmpegPath, _this3.optionsList, { stdio: 'pipe' });

            _this3._setupFFMPEGBuffers();

            _this3.ffmpegClosingPromise = _this3._getChildProcessPromise().then(function (code) {
                _this3.closed = true;

                if (code) {
                    _this3.debugLogger(code);
                    _this3.debugLogger(_this3.ffmpegStdoutBuf);
                    _this3.debugLogger(_this3.ffmpegStderrBuf);
                }
            }).catch(function (error) {
                _this3.closed = true;

                _this3.debugLogger(error);
                _this3.debugLogger(_this3.ffmpegStdoutBuf);
                _this3.debugLogger(_this3.ffmpegStderrBuf);
            });

            yield (0, _delay2.default)(FFMPEG_START_DELAY);
        })();
    }

    startCapturing() {
        var _this4 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            _this4.capturingPromise = _this4._capture();

            yield _this4.once('frame');
        })();
    }

    finishCapturing() {
        var _this5 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            if (_this5.closed) return;

            _this5.closed = true;

            yield _this5.capturingPromise;

            _this5.ffmpegProcess.stdin.end();

            yield _this5.ffmpegClosingPromise;
        })();
    }
}
exports.default = VideoRecorder;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92aWRlby1yZWNvcmRlci9wcm9jZXNzLmpzIl0sIm5hbWVzIjpbIkRFQlVHX0xPR0dFUl9QUkVGSVgiLCJERUZBVUxUX09QVElPTlMiLCJGRk1QRUdfU1RBUlRfREVMQVkiLCJWaWRlb1JlY29yZGVyIiwiQXN5bmNFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJiYXNlUGF0aCIsImZmbXBlZ1BhdGgiLCJjb25uZWN0aW9uIiwiY3VzdG9tT3B0aW9ucyIsImRlYnVnTG9nZ2VyIiwiaWQiLCJ2aWRlb1BhdGgiLCJmZm1wZWdQcm9jZXNzIiwiZmZtcGVnU3Rkb3V0QnVmIiwiZmZtcGVnU3RkZXJyQnVmIiwiZmZtcGVnQ2xvc2luZ1Byb21pc2UiLCJjbG9zZWQiLCJvcHRpb25zTGlzdCIsIl9nZXRPcHRpb25zTGlzdCIsImNhcHR1cmluZ1Byb21pc2UiLCJfZmlsdGVyT3B0aW9uIiwia2V5IiwidmFsdWUiLCJfc2V0dXBGRk1QRUdCdWZmZXJzIiwic3Rkb3V0Iiwib24iLCJkYXRhIiwiU3RyaW5nIiwic3RkZXJyIiwiX2dldENoaWxkUHJvY2Vzc1Byb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm9wdGlvbnNPYmplY3QiLCJtYXAiLCJwdXNoIiwiX2FkZEZyYW1lIiwiZnJhbWVEYXRhIiwid3JpdGluZ0ZpbmlzaGVkIiwic3RkaW4iLCJ3cml0ZSIsIm9uY2UiLCJyIiwiX2NhcHR1cmUiLCJmcmFtZSIsInByb3ZpZGVyIiwiZ2V0VmlkZW9GcmFtZURhdGEiLCJlbWl0IiwiZXJyb3IiLCJpbml0Iiwic3RkaW8iLCJ0aGVuIiwiY29kZSIsImNhdGNoIiwic3RhcnRDYXB0dXJpbmciLCJmaW5pc2hDYXB0dXJpbmciLCJlbmQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBR0EsTUFBTUEsc0JBQXNCLGtDQUE1Qjs7QUFFQSxNQUFNQyxrQkFB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QUF0QjtBQUNBLHVCQUFLSixXQUFMLENBQWlCLE9BQUtLLGVBQXRCO0FBQ0gsYUFqQnVCLENBQTVCOztBQW1CQSxrQkFBTSxxQkFBTWIsa0JBQU4sQ0FBTjtBQXhCVTtBQXlCYjs7QUFFS3FELGtCQUFOLEdBQXdCO0FBQUE7O0FBQUE7QUFDcEIsbUJBQUtuQyxnQkFBTCxHQUF3QixPQUFLd0IsUUFBTCxFQUF4Qjs7QUFFQSxrQkFBTSxPQUFLRixJQUFMLENBQVUsT0FBVixDQUFOO0FBSG9CO0FBSXZCOztBQUVLYyxtQkFBTixHQUF5QjtBQUFBOztBQUFBO0FBQ3JCLGdCQUFJLE9BQUt2QyxNQUFULEVBQ0k7O0FBRUosbUJBQUtBLE1BQUwsR0FBYyxJQUFkOztBQUVBLGtCQUFNLE9BQUtHLGdCQUFYOztBQUVBLG1CQUFLUCxhQUFMLENBQW1CMkIsS0FBbkIsQ0FBeUJpQixHQUF6Qjs7QUFFQSxrQkFBTSxPQUFLekMsb0JBQVg7QUFWcUI7QUFXeEI7QUE3SG1EO2tCQUFuQ2IsYSIsImZpbGUiOiJ2aWRlby1yZWNvcmRlci9wcm9jZXNzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCB7IHNwYXduIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgeyBmbGF0dGVuIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBQcm9taXNlIGZyb20gJ3BpbmtpZSc7XG5pbXBvcnQgQXN5bmNFbWl0dGVyIGZyb20gJy4uL3V0aWxzL2FzeW5jLWV2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IGRlbGF5IGZyb20gJy4uL3V0aWxzL2RlbGF5JztcblxuXG5jb25zdCBERUJVR19MT0dHRVJfUFJFRklYID0gJ3Rlc3RjYWZlOnZpZGVvLXJlY29yZGVyOnByb2Nlc3M6JztcblxuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIC8vIE5PVEU6IGRvbid0IGFzayBjb25maXJtYXRpb24gZm9yIHJld3JpdGluZyB0aGUgb3V0cHV0IGZpbGVcbiAgICAneSc6IHRydWUsXG5cbiAgICAvLyBOT1RFOiB1c2UgdGhlIHRpbWUgd2hlbiBhIGZyYW1lIGlzIHJlYWQgZnJvbSB0aGUgc291cmNlIGFzIGl0cyB0aW1lc3RhbXBcbiAgICAvLyBJTVBPUlRBTlQ6IG11c3QgYmUgc3BlY2lmaWVkIGJlZm9yZSBjb25maWd1cmluZyB0aGUgc291cmNlXG4gICAgJ3VzZV93YWxsY2xvY2tfYXNfdGltZXN0YW1wcyc6IDEsXG5cbiAgICAvLyBOT1RFOiB1c2Ugc3RkaW4gYXMgYSBzb3VyY2VcbiAgICAnaSc6ICdwaXBlOjAnLFxuXG4gICAgLy8gTk9URTogdXNlIHRoZSBILjI2NCB2aWRlbyBjb2RlY1xuICAgICdjOnYnOiAnbGlieDI2NCcsXG5cbiAgICAvLyBOT1RFOiB1c2UgdGhlICd1bHRyYWZhc3QnIGNvbXByZXNzaW9uIHByZXNldFxuICAgICdwcmVzZXQnOiAndWx0cmFmYXN0JyxcblxuICAgIC8vIE5PVEU6IHVzZSB0aGUgeXV2NDIwcCBwaXhlbCBmb3JtYXQgKHRoZSBtb3N0IHdpZGVseSBzdXBwb3J0ZWQpXG4gICAgJ3BpeF9mbXQnOiAneXV2NDIwcCcsXG5cbiAgICAvLyBOT1RFOiBzY2FsZSBpbnB1dCBmcmFtZXMgdG8gbWFrZSB0aGUgZnJhbWUgaGVpZ2h0IGRpdmlzaWJsZSBieSAyICh5dXY0MjBwJ3MgcmVxdWlyZW1lbnQpXG4gICAgJ3ZmJzogJ3NjYWxlPXRydW5jKGl3LzIpKjI6dHJ1bmMoaWgvMikqMicsXG5cbiAgICAvLyBOT1RFOiBzZXQgdGhlIGZyYW1lIHJhdGUgdG8gMzAgaW4gdGhlIG91dHB1dCB2aWRlbyAodGhlIG1vc3Qgd2lkZWx5IHN1cHBvcnRlZClcbiAgICAncic6IDMwXG59O1xuXG5jb25zdCBGRk1QRUdfU1RBUlRfREVMQVkgPSA1MDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZGVvUmVjb3JkZXIgZXh0ZW5kcyBBc3luY0VtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yIChiYXNlUGF0aCwgZmZtcGVnUGF0aCwgY29ubmVjdGlvbiwgY3VzdG9tT3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuZGVidWdMb2dnZXIgPSBkZWJ1ZyhERUJVR19MT0dHRVJfUFJFRklYICsgY29ubmVjdGlvbi5pZCk7XG5cbiAgICAgICAgdGhpcy5jdXN0b21PcHRpb25zID0gY3VzdG9tT3B0aW9ucztcbiAgICAgICAgdGhpcy52aWRlb1BhdGggICAgID0gYmFzZVBhdGg7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiAgICA9IGNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuZmZtcGVnUGF0aCAgICA9IGZmbXBlZ1BhdGg7XG4gICAgICAgIHRoaXMuZmZtcGVnUHJvY2VzcyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5mZm1wZWdTdGRvdXRCdWYgPSAnJztcbiAgICAgICAgdGhpcy5mZm1wZWdTdGRlcnJCdWYgPSAnJztcblxuICAgICAgICB0aGlzLmZmbXBlZ0Nsb3NpbmdQcm9taXNlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMub3B0aW9uc0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdCgpO1xuXG4gICAgICAgIHRoaXMuY2FwdHVyaW5nUHJvbWlzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgc3RhdGljIF9maWx0ZXJPcHRpb24gKFtrZXksIHZhbHVlXSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gWyctJyArIGtleV07XG5cbiAgICAgICAgcmV0dXJuIFsnLScgKyBrZXksIHZhbHVlXTtcbiAgICB9XG5cbiAgICBfc2V0dXBGRk1QRUdCdWZmZXJzICgpIHtcbiAgICAgICAgdGhpcy5mZm1wZWdQcm9jZXNzLnN0ZG91dC5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgICAgICAgdGhpcy5mZm1wZWdTdGRvdXRCdWYgKz0gU3RyaW5nKGRhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZmbXBlZ1Byb2Nlc3Muc3RkZXJyLm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZmbXBlZ1N0ZGVyckJ1ZiArPSBTdHJpbmcoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9nZXRDaGlsZFByb2Nlc3NQcm9taXNlICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmZtcGVnUHJvY2Vzcy5vbignZXhpdCcsIHJlc29sdmUpO1xuICAgICAgICAgICAgdGhpcy5mZm1wZWdQcm9jZXNzLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9nZXRPcHRpb25zTGlzdCAoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIHRoaXMuY3VzdG9tT3B0aW9ucyk7XG5cbiAgICAgICAgY29uc3Qgb3B0aW9uc0xpc3QgPSBmbGF0dGVuKE9iamVjdC5lbnRyaWVzKG9wdGlvbnNPYmplY3QpLm1hcChWaWRlb1JlY29yZGVyLl9maWx0ZXJPcHRpb24pKTtcblxuICAgICAgICBvcHRpb25zTGlzdC5wdXNoKHRoaXMudmlkZW9QYXRoKTtcblxuICAgICAgICByZXR1cm4gb3B0aW9uc0xpc3Q7XG4gICAgfVxuXG4gICAgYXN5bmMgX2FkZEZyYW1lIChmcmFtZURhdGEpIHtcbiAgICAgICAgY29uc3Qgd3JpdGluZ0ZpbmlzaGVkID0gdGhpcy5mZm1wZWdQcm9jZXNzLnN0ZGluLndyaXRlKGZyYW1lRGF0YSk7XG5cbiAgICAgICAgaWYgKCF3cml0aW5nRmluaXNoZWQpXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHRoaXMuZmZtcGVnUHJvY2Vzcy5zdGRpbi5vbmNlKCdkcmFpbicsIHIpKTtcbiAgICB9XG5cbiAgICBhc3luYyBfY2FwdHVyZSAoKSB7XG4gICAgICAgIHdoaWxlICghdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJhbWUgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIuZ2V0VmlkZW9GcmFtZURhdGEodGhpcy5jb25uZWN0aW9uLmlkKTtcblxuICAgICAgICAgICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmVtaXQoJ2ZyYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2FkZEZyYW1lKGZyYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nZ2VyKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGluaXQgKCkge1xuICAgICAgICB0aGlzLmZmbXBlZ1Byb2Nlc3MgPSBzcGF3bih0aGlzLmZmbXBlZ1BhdGgsIHRoaXMub3B0aW9uc0xpc3QsIHsgc3RkaW86ICdwaXBlJyB9KTtcblxuICAgICAgICB0aGlzLl9zZXR1cEZGTVBFR0J1ZmZlcnMoKTtcblxuICAgICAgICB0aGlzLmZmbXBlZ0Nsb3NpbmdQcm9taXNlID0gdGhpc1xuICAgICAgICAgICAgLl9nZXRDaGlsZFByb2Nlc3NQcm9taXNlKClcbiAgICAgICAgICAgIC50aGVuKGNvZGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2dnZXIoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2dnZXIodGhpcy5mZm1wZWdTdGRvdXRCdWYpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nZ2VyKHRoaXMuZmZtcGVnU3RkZXJyQnVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nZ2VyKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nZ2VyKHRoaXMuZmZtcGVnU3Rkb3V0QnVmKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nZ2VyKHRoaXMuZmZtcGVnU3RkZXJyQnVmKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IGRlbGF5KEZGTVBFR19TVEFSVF9ERUxBWSk7XG4gICAgfVxuXG4gICAgYXN5bmMgc3RhcnRDYXB0dXJpbmcgKCkge1xuICAgICAgICB0aGlzLmNhcHR1cmluZ1Byb21pc2UgPSB0aGlzLl9jYXB0dXJlKCk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5vbmNlKCdmcmFtZScpO1xuICAgIH1cblxuICAgIGFzeW5jIGZpbmlzaENhcHR1cmluZyAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5jYXB0dXJpbmdQcm9taXNlO1xuXG4gICAgICAgIHRoaXMuZmZtcGVnUHJvY2Vzcy5zdGRpbi5lbmQoKTtcblxuICAgICAgICBhd2FpdCB0aGlzLmZmbXBlZ0Nsb3NpbmdQcm9taXNlO1xuICAgIH1cbn1cbiJdfQ==
